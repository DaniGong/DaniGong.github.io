<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Pythonic🐶</title>
    <link>http://danigong.github.io/</link>
    <description>Recent content on Pythonic🐶</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 26 Apr 2018 16:29:42 +0800</lastBuildDate>
    <atom:link href="http://danigong.github.io/feed/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>使用pip安装包提示TLS证书错误解决办法</title>
      <link>http://danigong.github.io/post/pip_install_TLS_ERROR/</link>
      <pubDate>Thu, 26 Apr 2018 16:29:42 +0800</pubDate>
      
      <guid>http://danigong.github.io/post/pip_install_TLS_ERROR/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Could not fetch URL https://pypi.python.org/simple/pytest-xdist/: There was a problem confirming the ssl certificate: [SSL: TLSV1_ALERT_PROTOCOL_VERSION] tlsv1 alert protocol version (_ssl.c:590) - skipping&lt;/code&gt;
出现这个错误的原因是python.org已经不支持TLSv1.0和TLSv1.1了。更新pip可以解决这个问题。但是如果使用传统的&lt;code&gt;python -m pip install --upgrade pip&lt;/code&gt;的方式，还是会出现那个问题。这是一个鸡和蛋的问题，你因为TLS证书的问题需要去升级pip，升pip的时候又因为TLS证书的原因不能下载最新版本的pip。这时候就没有办法了，只能手动的去升级pip。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;mac或者linux操作系统：在终端下执行命令：&lt;code&gt;curl https://bootstrap.pypa.io/get-pip.py | python&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;windows操作系统：从&lt;a href=&#34;https://bootstrap.pypa.io/get-pip.py下载get-pip.py文件，然后使用python运行这个文件`python&#34;&gt;https://bootstrap.pypa.io/get-pip.py下载get-pip.py文件，然后使用python运行这个文件`python&lt;/a&gt; get-pip.py`即可。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Java Thread Dump</title>
      <link>http://danigong.github.io/post/java_thread_dump/</link>
      <pubDate>Sat, 17 Mar 2018 16:59:13 +0800</pubDate>
      
      <guid>http://danigong.github.io/post/java_thread_dump/</guid>
      <description>&lt;p&gt;转载自：&lt;a href=&#34;http://blog.csdn.net/rachel_luo/article/details/8920596&#34;&gt;http://blog.csdn.net/rachel_luo/article/details/8920596&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、Thread Dump介绍&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.1什么是Thread Dump？&lt;/p&gt;

&lt;p&gt;Thread Dump是非常有用的诊断Java应用问题的工具。每一个Java虚拟机都有及时生成所有线程在某一点状态的thread-dump的能力，虽然各个 Java虚拟机打印的thread dump略有不同，但是大多都提供了当前活动线程的快照，及JVM中所有Java线程的堆栈跟踪信息，堆栈信息一般包含完整的类名及所执行的方法，如果可能的话还有源代码的行数。&lt;/p&gt;

&lt;p&gt;1.2 Thread Dump特点&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;能在各种操作系统下使用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;能在各种Java应用服务器下使用&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以在生产环境下使用而不影响系统的性能&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可以将问题直接定位到应用程序的代码行上&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1.3 Thread Dump 能诊断的问题&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;查找内存泄露，常见的是程序里load大量的数据到缓存；&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;发现死锁线程；&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;1.4如何抓取Thread Dump&lt;/p&gt;

&lt;p&gt;一般当服务器挂起,崩溃或者性能底下时,就需要抓取服务器的线程堆栈(Thread Dump)用于后续的分析. 在实际运行中，往往一次 dump的信息，还不足以确认问题。为了反映线程状态的动态变化，需要接连多次做threaddump，每次间隔10-20s，建议至少产生三次 dump信息，如果每次 dump都指向同一个问题，我们才确定问题的典型性。&lt;/p&gt;

&lt;p&gt;有很多方式可用于获取ThreadDump, 下面列出一部分获取方式：&lt;/p&gt;

&lt;p&gt;操作系统命令获取ThreadDump:&lt;/p&gt;

&lt;p&gt;Windows:&lt;/p&gt;

&lt;p&gt;1.转向服务器的标准输出窗口并按下Control + Break组合键, 之后需要将线程堆栈复制到文件中；&lt;/p&gt;

&lt;p&gt;UNIX/ Linux：&lt;/p&gt;

&lt;p&gt;首先查找到服务器的进程号(process id), 然后获取线程堆栈.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ps –ef  | grep java&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;kill -3 &lt;pid&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意：一定要谨慎, 一步不慎就可能让服务器进程被杀死。kill -9 命令会杀死进程。&lt;/p&gt;

&lt;p&gt;JVM 自带的工具获取线程堆栈:&lt;/p&gt;

&lt;p&gt;JDK自带命令行工具获取PID，再获取ThreadDump:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;jps 或 ps –ef|grepjava (获取PID)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;jstack [-l ]&lt;pid&gt; | tee -a jstack.log  (获取ThreadDump)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;二、java线程的状态转换介绍(为后续分析做准备)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;2.1 新建状态（New）&lt;/p&gt;

&lt;p&gt;用new语句创建的线程处于新建状态，此时它和其他Java对象一样，仅仅在堆区中被分配了内存。&lt;/p&gt;

&lt;p&gt;2.2 就绪状态（Runnable）&lt;/p&gt;

&lt;p&gt;当一个线程对象创建后，其他线程调用它的start()方法，该线程就进入就绪状态，Java虚拟机会为它创建方法调用栈和程序计数器。处于这个状态的线程位于可运行池中，等待获得CPU的使用权。&lt;/p&gt;

&lt;p&gt;2.3 运行状态（Running）&lt;/p&gt;

&lt;p&gt;处于这个状态的线程占用CPU，执行程序代码。只有处于就绪状态的线程才有机会转到运行状态。&lt;/p&gt;

&lt;p&gt;2.4 阻塞状态（Blocked）&lt;/p&gt;

&lt;p&gt;阻塞状态是指线程因为某些原因放弃CPU，暂时停止运行。当线程处于阻塞状态时，Java虚拟机不会给线程分配CPU。直到线程重新进入就绪状态，它才有机会转到运行状态。&lt;/p&gt;

&lt;p&gt;阻塞状态可分为以下3种：&lt;/p&gt;

&lt;p&gt;1）位于对象等待池中的阻塞状态（Blocked in object’s wait pool）：当线程处于运行状态时，如果执行了某个对象的wait()方法，Java虚拟机就会把线程放到这个对象的等待池中，这涉及到“线程通信”的内容。&lt;/p&gt;

&lt;p&gt;2）位于对象锁池中的阻塞状态（Blocked in object’s lock pool）：当线程处于运行状态时，试图获得某个对象的同步锁时，如果该对象的同步锁已经被其他线程占用，Java虚拟机就会把这个线程放到这个对象的锁池中，这涉及到“线程同步”的内容。&lt;/p&gt;

&lt;p&gt;3）其他阻塞状态（Otherwise Blocked）：当前线程执行了sleep()方法，或者调用了其他线程的join()方法，或者发出了I/O请求时，就会进入这个状态。&lt;/p&gt;

&lt;p&gt;2.5 死亡状态（Dead）&lt;/p&gt;

&lt;p&gt;当线程退出run()方法时，就进入死亡状态，该线程结束生命周期。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、Thread Dump分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过前面1.4部分的方法，获取Thread Dump信息后，对其进行分析；&lt;/p&gt;

&lt;p&gt;3.1 首先介绍一下Thread Dump信息的各个部分&lt;/p&gt;

&lt;p&gt;头部信息：&lt;/p&gt;

&lt;p&gt;时间，jvm信息&lt;/p&gt;

&lt;p&gt;2011-11-02 19:05:06&lt;/p&gt;

&lt;p&gt;Full thread dump Java HotSpot&amp;trade; Server VM (16.3-b01 mixed mode):&lt;/p&gt;

&lt;p&gt;线程info信息块：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&amp;ldquo;Timer-0&amp;rdquo; daemon prio=10tid=0xac190c00 nid=0xaef in Object.wait() [0xae77d000]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;java.lang.Thread.State: TIMED_WAITING (on object monitor)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;atjava.lang.Object.wait(Native Method)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-waiting on &lt;0xb3885f60&gt; (a java.util.TaskQueue)     ###继续wait&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;atjava.util.TimerThread.mainLoop(Timer.java:509)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-locked &lt;0xb3885f60&gt; (a java.util.TaskQueue)         ###已经locked&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;atjava.util.TimerThread.run(Timer.java:462)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;线程名称：Timer-0&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;线程类型：daemon&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;优先级: 10，默认是5&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;jvm线程id：tid=0xac190c00，jvm内部线程的唯一标识（通过java.lang.Thread.getId()获取，通常用自增方式实现。）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对应系统线程id（NativeThread ID）：nid=0xaef，和top命令查看的线程pid对应，不过一个是10进制，一个是16进制。（通过命令：top -H -p pid，可以查看该进程的所有线程信息）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;线程状态：in Object.wait().&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;起始栈地址：[0xae77d000]&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java thread statck trace：是上面2-7行的信息。到目前为止这是最重要的数据，Java stack trace提供了大部分信息来精确定位问题根源。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于thread dump信息，主要关注的是线程的状态和其执行堆栈。现在针对这两个重点部分进行讲解：&lt;/p&gt;

&lt;p&gt;1）Java thread statck trace详解：&lt;/p&gt;

&lt;p&gt;堆栈信息应该逆向解读：程序先执行的是第7行，然后是第6行，依次类推。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;locked &lt;0xb3885f60&gt; (a java.util.ArrayList)&lt;/li&gt;
&lt;li&gt;waiting on &lt;0xb3885f60&gt; (a java.util.ArrayList)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也就是说对象先上锁，锁住对象0xb3885f60，然后释放该对象锁，进入waiting状态。&lt;/p&gt;

&lt;p&gt;为啥会出现这样的情况呢？看看下面的java代码示例，就会明白：&lt;/p&gt;

&lt;p&gt;synchronized(obj) {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   .........  

   obj.wait();  

   .........  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;在堆栈的第一行信息中，进一步标明了线程在代码级的状态，例如：&lt;/p&gt;

&lt;p&gt;java.lang.Thread.State: TIMED_WAITING (parking)&lt;/p&gt;

&lt;p&gt;解释如下：&lt;/p&gt;

&lt;p&gt;|blocked|&lt;/p&gt;

&lt;p&gt;This thread tried to enter asynchronized block, but the lock was taken by another thread. This thread isblocked until the lock gets released.&lt;/p&gt;

&lt;p&gt;|blocked (on thin lock)|&lt;/p&gt;

&lt;p&gt;This is the same state asblocked, but the lock in question is a thin lock.&lt;/p&gt;

&lt;p&gt;|waiting|&lt;/p&gt;

&lt;p&gt;This thread calledObject.wait() on an object. The thread will remain there until some otherthread sends a notification to that object.&lt;/p&gt;

&lt;p&gt;|sleeping|&lt;/p&gt;

&lt;p&gt;This thread calledjava.lang.Thread.sleep().&lt;/p&gt;

&lt;p&gt;|parked|&lt;/p&gt;

&lt;p&gt;This thread calledjava.util.concurrent.locks.LockSupport.park().&lt;/p&gt;

&lt;p&gt;|suspended|&lt;/p&gt;

&lt;p&gt;The thread&amp;rsquo;s execution wassuspended by java.lang.Thread.suspend() or a JVMTI agent call.&lt;/p&gt;

&lt;p&gt;2) 线程状态详解：&lt;/p&gt;

&lt;p&gt;Runnable
&lt;em&gt;The thread is either running or ready to run when it gets its CPU turn.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Wait on condition
&lt;em&gt;The thread is either sleeping or waiting to be notified by another thread.&lt;/em&gt;
    该状态出现在线程等待某个条件的发生或者sleep。具体是什么原因，可以结合 stacktrace来分析。最常见的情况是线程在等待网络的读写，比如当网络数据没有准备好读时，线程处于这种等待状态，而一旦有数据准备好读之后，线程会重新激活，读取并处理数据。在Java引入 New IO之前，对于每个网络连接，都有一个对应的线程来处理网络的读写操作，即使没有可读写的数据，线程仍然阻塞在读写操作上，这样有可能造成资源浪费，而且给操作系统的线程调度也带来压力。在 New IO里采用了新的机制，编写的服务器程序的性能和可扩展性都得到提高。
    如果发现有大量的线程都处在 Wait on condition，从线程 stack看， 正等待网络读写，这可能是一个网络瓶颈的征兆。因为网络阻塞导致线程无法执行。一种情况是网络非常忙，几乎消耗了所有的带宽，仍然有大量数据等待网络读写；另一种情况也可能是网络空闲，但由于路由等问题，导致包无法正常的到达。所以要结合系统的一些性能观察工具来综合分析，比如 netstat统计单位时间的发送包的数目，看是否很明显超过了所在网络带宽的限制；观察cpu的利用率，看系统态的CPU时间是否明显大于用户态的CPU时间；如果程序运行在 Solaris 10平台上，可以用dtrace工具看系统调用的情况，如果观察到 read/write的系统调用的次数或者运行时间遥遥领先；这些都指向由于网络带宽所限导致的网络瓶颈。另外一种出现 Wait on condition的常见情况是该线程在 sleep，等待 sleep的时间到了，将被唤醒。&lt;/p&gt;

&lt;p&gt;Waiting for Monitor Entry and in Object.wait()&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The thread is waiting to getthe lock for an object (some other thread may be holding the lock). Thishappens if two or more threads try to execute synchronized code. Note that thelock is always for an object and not for individual methods.&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;在多线程的 JAVA程序中，实现线程之间的同步，就要说说 Monitor。 Monitor是Java中用以实现线程之间的互斥与协作的主要手段，它可以看成是对象或者 Class的锁。每一个对象都有，也仅有一个 monitor。每个 Monitor在某个时刻，只能被一个线程拥有，该线程就是 “ActiveThread”，而其它线程都是 “Waiting Thread”，分别在两个队列 “ Entry Set”和 “Wait Set”里面等候。在 “Entry Set”中等待的线程状态是 “Waiting for monitorentry”，而在 “Wait Set”中等待的线程状态是“in Object.wait()”。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先看 “Entry Set”里面的线程。我们称被 synchronized保护起来的代码段为临界区。当一个线程申请进入临界区时，它就进入了 “Entry Set”队列。对应的 code就像：
synchronized(obj) {
    &amp;hellip;&amp;hellip;&amp;hellip;
}
这时有两种可能性：
    该 monitor不被其它线程拥有， Entry Set里面也没有其它等待线程。本线程即成为相应类或者对象的 Monitor的 Owner，执行临界区的代码。
    该 monitor被其它线程拥有，本线程在 Entry Set队列中等待。
    在第一种情况下，线程将处于 “Runnable”的状态，而第二种情况下，线程 DUMP会显示处于 “waiting for monitor entry”。&lt;/p&gt;

&lt;p&gt;临界区的设置，是为了保证其内部的代码执行的原子性和完整性。但是因为临界区在任何时间只允许线程串行通过，这和我们多线程的程序的初衷是相反的。如果在多线程的程序中，大量使用 synchronized，或者不适当的使用了它，会造成大量线程在临界区的入口等待，造成系统的性能大幅下降。如果在线程 DUMP中发现了这个情况，应该审查源码，改进程序。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;再看“Wait Set”里面的线程。当线程获得了 Monitor，进入了临界区之后，如果发现线程继续运行的条件没有满足，它则调用对象（一般就是被 synchronized 的对象）的 wait() 方法，放弃 Monitor，进入 “Wait Set”队列。只有当别的线程在该对象上调用了 notify() 或者 notifyAll()，“Wait Set”队列中线程才得到机会去竞争，但是只有一个线程获得对象的Monitor，恢复到运行态。在 “Wait Set”中的线程， DUMP中表现为： in Object.wait()。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般，Cpu很忙时，则关注runnable的线程，Cpu很闲时，则关注waiting for monitor entry的线程。&lt;/p&gt;

&lt;p&gt;3.2 JVM线程介绍&lt;/p&gt;

&lt;p&gt;在Thread Dump中，有一些 JVM内部的后台线程，来执行譬如垃圾回收，或者低内存的检测等等任务，这些线程往往在 JVM初始化的时候就存在，如下所示：&lt;/p&gt;

&lt;p&gt;HotSpot VM Thread&lt;/p&gt;

&lt;p&gt;被HotSpot VM管理的内部线程为了完成内部本地操作，一般来说不需要担心它们，除非CPU很高。&lt;/p&gt;

&lt;p&gt;&amp;ldquo;VM Periodic Task Thread&amp;rdquo; prio=10tid=0xad909400 nid=0xaed waiting on condition&lt;/p&gt;

&lt;p&gt;HotSpot GC Thread&lt;/p&gt;

&lt;p&gt;当使用HotSpot parallel GC，HotSpot VM默认创建一定数目的GC thread。&lt;/p&gt;

&lt;p&gt;&amp;ldquo;GC task thread#0 (ParallelGC)&amp;ldquo;prio=10 tid=0xf690b400 nid=0xade runnable&lt;/p&gt;

&lt;p&gt;&amp;ldquo;GC task thread#1 (ParallelGC)&amp;ldquo;prio=10 tid=0xf690cc00 nid=0xadf runnable&lt;/p&gt;

&lt;p&gt;&amp;ldquo;GC task thread#2 (ParallelGC)&amp;ldquo;prio=10 tid=0xf690e000 nid=0xae0 runnable&lt;/p&gt;

&lt;p&gt;……&lt;/p&gt;

&lt;p&gt;当面对过多GC，内存泄露等问题时，这些是关键的数据。使用native id，可以将从OS/Java进程观测到的高CPU与这些线程关联起来。&lt;/p&gt;

&lt;p&gt;JNI global references count&lt;/p&gt;

&lt;p&gt;JNI global reference是基本的对象引用，从本地代码到被Java GC管理的Java对象的引用。其角色是阻止仍然被本地代码使用的对象集合，但在Java代码中没有引用。在探测JNI相关内存泄露时，关注JNI references很重要。如果你的程序直接使用JNI或使用第三方工具，如检测工具，检测本地内存泄露。&lt;/p&gt;

&lt;p&gt;JNI global references: 832&lt;/p&gt;

&lt;p&gt;Java Heap utilization view&lt;/p&gt;

&lt;p&gt;从jdk1.6开始在thread dump快照底部，可以找到崩溃点的内存空间利用情况:YongGen,OldGen和PermGen。目前我测试的系统导出的thread dump，还未见到这一部分内容（sun jdk1.6）。以下例子，摘自他人文章：&lt;/p&gt;

&lt;p&gt;Heap&lt;/p&gt;

&lt;p&gt;PSYoungGen      total 466944K, used 178734K [0xffffffff45c00000, 0xffffffff70800000, 0xffffffff70800000)&lt;/p&gt;

&lt;p&gt;eden space 233472K, 76% used [0xffffffff45c00000,0xffffffff50ab7c50,0xffffffff54000000)&lt;/p&gt;

&lt;p&gt;from space 233472K, 0% used [0xffffffff62400000,0xffffffff62400000,0xffffffff70800000)&lt;/p&gt;

&lt;p&gt;to   space 233472K, 0% used [0xffffffff54000000,0xffffffff54000000,0xffffffff62400000)&lt;/p&gt;

&lt;p&gt;PSOldGen        total 1400832K, used 1400831K [0xfffffffef0400000, 0xffffffff45c00000, 0xffffffff45c00000)&lt;/p&gt;

&lt;p&gt;object space 1400832K, 99% used [0xfffffffef0400000,0xffffffff45bfffb8,0xffffffff45c00000)&lt;/p&gt;

&lt;p&gt;PSPermGen       total 262144K, used 248475K [0xfffffffed0400000, 0xfffffffee0400000, 0xfffffffef0400000)&lt;/p&gt;

&lt;p&gt;object space 262144K, 94% used [0xfffffffed0400000,0xfffffffedf6a6f08,0xfffffffee0400000)&lt;/p&gt;

&lt;p&gt;还有一些其他的线程（如下），不一一介绍了，有兴趣，可查看文章最后的附件信息。&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Low Memory Detector&amp;rdquo; daemon prio=10tid=0xad907400 nid=0xaec runnable [0x00000000]&lt;/p&gt;

&lt;p&gt;&amp;ldquo;CompilerThread1&amp;rdquo; daemon prio=10tid=0xad905400 nid=0xaeb waiting on condition [0x00000000]&lt;/p&gt;

&lt;p&gt;&amp;ldquo;CompilerThread0&amp;rdquo; daemon prio=10tid=0xad903c00 nid=0xaea waiting on condition [0x00000000]&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Signal Dispatcher&amp;rdquo; daemon prio=10tid=0xad902400 nid=0xae9 runnable [0x00000000]&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Finalizer&amp;rdquo; daemon prio=10tid=0xf69eec00 nid=0xae8 in Object.wait() [0xaf17d000]&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Reference Handler&amp;rdquo; daemon prio=10tid=0xf69ed800 nid=0xae7 in Object.wait() [0xae1e7000]&lt;/p&gt;

&lt;p&gt;&amp;ldquo;VM Thread&amp;rdquo; prio=10 tid=0xf69e9800nid=0xae6 runnable&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、案例分析：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;4.1、使用方案&lt;/p&gt;

&lt;p&gt;cpu飙高，load高，响应很慢&lt;/p&gt;

&lt;p&gt;方案：
* 一个请求过程中多次dump&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对比多次dump文件的runnable线程，如果执行的方法有比较大变化，说明比较正常。如果在执行同一个方法，就有一些问题了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;查找占用cpu最多的线程信息&lt;/p&gt;

&lt;p&gt;方案：
* 使用命令： top -H -p pid（pid为被测系统的进程号），找到导致cpu高的线程id。&lt;/p&gt;

&lt;p&gt;上述Top命令找到的线程id，对应着dump thread信息中线程的nid，只不过一个是十进制，一个是十六进制。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在thread dump中，根据top命令查找的线程id，查找对应的线程堆栈信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;cpu使用率不高但是响应很慢&lt;/p&gt;

&lt;p&gt;方案：
* 进行dump，查看是否有很多thread struck在了i/o、数据库等地方，定位瓶颈原因。&lt;/p&gt;

&lt;p&gt;请求无法响应&lt;/p&gt;

&lt;p&gt;方案：
* 多次dump，对比是否所有的runnable线程都一直在执行相同的方法，如果是的，恭喜你，锁住了！&lt;/p&gt;

&lt;p&gt;4.2 案例分析：&lt;/p&gt;

&lt;p&gt;1.死锁：&lt;/p&gt;

&lt;p&gt;死锁经常表现为程序的停顿，或者不再响应用户的请求。从操作系统上观察，对应进程的CPU占用率为零，很快会从top或prstat的输出中消失。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;在thread dump中，会看到类似于这样的信息：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;（图 1）&lt;/p&gt;

&lt;p&gt;（图2）&lt;/p&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;p&gt;（图1）中有一个“Waiting formonitor entry”，可以看出，两个线程各持有一个锁，又在等待另一个锁，很明显这两个线程互相持有对方正在等待的锁。所以造成了死锁现象；&lt;/p&gt;

&lt;p&gt;（图2）中对死锁的现象做了说明，可以看到，是“DeadLockTest.java”的39行造成的死锁现象。这样就能到相应的代码下去查看，定位问题。&lt;/p&gt;

&lt;p&gt;2.热锁&lt;/p&gt;

&lt;p&gt;热锁，也往往是导致系统性能瓶颈的主要因素。其表现特征为：由于多个线程对临界区，或者锁的竞争，可能出现：
    * 频繁的线程的上下文切换：从操作系统对线程的调度来看，当线程在等待资源而阻塞的时候，操作系统会将之切换出来，放到等待的队列，当线程获得资源之后，调度算法会将这个线程切换进去，放到执行队列中。
    * 大量的系统调用：因为线程的上下文切换，以及热锁的竞争，或者临界区的频繁的进出，都可能导致大量的系统调用。
    * 大部分CPU开销用在“系统态 ”：线程上下文切换，和系统调用，都会导致 CPU在 “系统态 ”运行，换而言之，虽然系统很忙碌，但是 CPU用在 “用户态 ”的比例较小，应用程序得不到充分的 CPU资源。
    * 随着 CPU数目的增多，系统的性能反而下降。因为CPU数目多，同时运行的线程就越多，可能就会造成更频繁的线程上下文切换和系统态的CPU开销，从而导致更糟糕的性能。
    上面的描述，都是一个 scalability（可扩展性）很差的系统的表现。从整体的性能指标看，由于线程热锁的存在，程序的响应时间会变长，吞吐量会降低。
    那么，怎么去了解 “热锁 ”出现在什么地方呢？一个重要的方法还是结合操作系统的各种工具观察系统资源使用状况，以及收集Java线程的DUMP信息，看线程都阻塞在什么方法上，了解原因，才能找到对应的解决方法。
    我们曾经遇到过这样的例子，程序运行时，出现了以上指出的各种现象，通过观察操作系统的资源使用统计信息，以及线程 DUMP信息，确定了程序中热锁的存在，并发现大多数的线程状态都是 Waitingfor monitor entry或者 Wait on monitor，且是阻塞在压缩和解压缩的方法上。后来采用第三方的压缩包 javalib替代 JDK自带的压缩包后，系统的性能提高了几倍。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;五、附件：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JVM运行过程中产生的一些比较重要的线程罗列如下：&lt;/p&gt;

&lt;p&gt;线程名称&lt;/p&gt;

&lt;p&gt;所属&lt;/p&gt;

&lt;p&gt;解释说明&lt;/p&gt;

&lt;p&gt;Attach Listener&lt;/p&gt;

&lt;p&gt;JVM&lt;/p&gt;

&lt;p&gt;Attach Listener 线程是负责接收到外部的命令，而对该命令进行执行的并且吧结果返回给发送者。通常我们会用一些命令去要求jvm给我们一些反馈信息，如：java -version、jmap、jstack等等。 如果该线程在jvm启动的时候没有初始化，那么，则会在用户第一次执行jvm命令时，得到启动。&lt;/p&gt;

&lt;p&gt;Signal Dispatcher&lt;/p&gt;

&lt;p&gt;JVM&lt;/p&gt;

&lt;p&gt;前面我们提到第一个Attach Listener线程的职责是接收外部jvm命令，当命令接收成功后，会交给signal dispather 线程去进行分发到各个不同的模块处理命令，并且返回处理结果。 signal dispather线程也是在第一次接收外部jvm命令时，进行初始化工作。&lt;/p&gt;

&lt;p&gt;CompilerThread0&lt;/p&gt;

&lt;p&gt;JVM&lt;/p&gt;

&lt;p&gt;用来调用JITing，实时编译装卸class 。 通常，jvm会启动多个线程来处理这部分工作，线程名称后面的数字也会累加，例如：CompilerThread1&lt;/p&gt;

&lt;p&gt;Concurrent Mark-Sweep GC Thread&lt;/p&gt;

&lt;p&gt;JVM&lt;/p&gt;

&lt;p&gt;并发标记清除垃圾回收器（就是通常所说的CMS GC）线程， 该线程主要针对于老年代垃圾回收。ps：启用该垃圾回收器，需要在jvm启动参数中加上： -XX:+UseConcMarkSweepGC&lt;/p&gt;

&lt;p&gt;DestroyJavaVM&lt;/p&gt;

&lt;p&gt;JVM&lt;/p&gt;

&lt;p&gt;执行main()的线程在main执行完后调用JNI中的 jni_DestroyJavaVM() 方法唤起DestroyJavaVM 线程。&lt;/p&gt;

&lt;p&gt;JVM在 Jboss 服务器启动之后，就会唤起DestroyJavaVM线程，处于等待状态，等待其它线程（java线程和native线程）退出时通知它卸载JVM。线程退出时，都会判断自己当前是否是整个JVM中最后一个非deamon线程，如果是，则通知DestroyJavaVM 线程卸载JVM。&lt;/p&gt;

&lt;p&gt;ps：&lt;/p&gt;

&lt;p&gt;扩展一下：&lt;/p&gt;

&lt;p&gt;1.如果线程退出时判断自己不为最后一个非deamon线程，那么调用thread-&amp;gt;exit(false) ，并在其中抛出thread_end事件，jvm不退出。&lt;/p&gt;

&lt;p&gt;2.如果线程退出时判断自己为最后一个非deamon线程，那么调用before_exit() 方法，抛出两个事件：&lt;/p&gt;

&lt;p&gt;事件1：thread_end 线程结束事件；&lt;/p&gt;

&lt;p&gt;事件2：VM的death事件。&lt;/p&gt;

&lt;p&gt;然后调用thread-&amp;gt;exit(true) 方法，接下来把线程从active list卸下，删除线程等等一系列工作执行完成后，则通知正在等待的DestroyJavaVM 线程执行卸载JVM操作。&lt;/p&gt;

&lt;p&gt;ContainerBackgroundProcessor 线程&lt;/p&gt;

&lt;p&gt;JBOSS&lt;/p&gt;

&lt;p&gt;它是一个守护线程, 在jboss服务器在启动的时候就初始化了,主要工作是定期去检查有没有Session过期.过期则清除.&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://liudeh-009.iteye.com/blog/1584876&#34;&gt;http://liudeh-009.iteye.com/blog/1584876&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Dispatcher-Thread-3  线程&lt;/p&gt;

&lt;p&gt;Log4j&lt;/p&gt;

&lt;p&gt;Log4j具有异步打印日志的功能，需要异步打印日志的Appender都需要注册到 AsyncAppender对象里面去，由AsyncAppender进行监听，决定何时触发日志打印操作。 AsyncAppender如果监听到它管辖范围内的Appender有打印日志的操作，则给这个Appender生成一个相应的event，并将该event保存在一个buffuer区域内。&lt;/p&gt;

&lt;p&gt;Dispatcher-Thread-3线程负责判断这个event缓存区是否已经满了，如果已经满了，则将缓存区内的所有event分发到Appender容器里面去，那些注册上来的Appender收到自己的event后，则开始处理自己的日志打印工作。 Dispatcher-Thread-3线程是一个守护线程。&lt;/p&gt;

&lt;p&gt;Finalizer线程&lt;/p&gt;

&lt;p&gt;JVM&lt;/p&gt;

&lt;p&gt;这个线程也是在main线程之后创建的，其优先级为10，主要用于在垃圾收集前，调用对象的finalize()方法；关于Finalizer线程的几点：&lt;/p&gt;

&lt;p&gt;1) 只有当开始一轮垃圾收集时，才会开始调用finalize()方法；因此并不是所有对象的finalize()方法都会被执行；&lt;/p&gt;

&lt;p&gt;2) 该线程也是daemon线程，因此如果虚拟机中没有其他非daemon线程，不管该线程有没有执行完finalize()方法，JVM也会退出；&lt;/p&gt;

&lt;p&gt;3) JVM在垃圾收集时会将失去引用的对象包装成Finalizer对象（Reference的实现），并放入ReferenceQueue，由Finalizer线程来处理；最后将该Finalizer对象的引用置为null，由垃圾收集器来回收；&lt;/p&gt;

&lt;p&gt;4) JVM为什么要单独用一个线程来执行finalize()方法呢？如果JVM的垃圾收集线程自己来做，很有可能由于在finalize()方法中误操作导致GC线程停止或不可控，这对GC线程来说是一种灾难；&lt;/p&gt;

&lt;p&gt;Gang worker#0&lt;/p&gt;

&lt;p&gt;JVM&lt;/p&gt;

&lt;p&gt;JVM 用于做新生代垃圾回收（monir gc）的一个线程。#号后面是线程编号，例如：Gang worker#1&lt;/p&gt;

&lt;p&gt;GC Daemon&lt;/p&gt;

&lt;p&gt;JVM&lt;/p&gt;

&lt;p&gt;GC Daemon 线程是JVM为RMI提供远程分布式GC使用的，GC Daemon线程里面会主动调用System.gc()方法，对服务器进行Full GC。 其初衷是当 RMI 服务器返回一个对象到其客户机（远程方法的调用方）时，其跟踪远程对象在客户机中的使用。当再没有更多的对客户机上远程对象的引用时，或者如果引用的“租借”过期并且没有更新，服务器将垃圾回收远程对象。&lt;/p&gt;

&lt;p&gt;不过，我们现在jvm启动参数都加上了-XX:+DisableExplicitGC配置，所以，这个线程只有打酱油的份了。&lt;/p&gt;

&lt;p&gt;IdleRemover&lt;/p&gt;

&lt;p&gt;JBOSS&lt;/p&gt;

&lt;p&gt;Jboss连接池有一个最小值， 该线程每过一段时间都会被Jboss唤起，用于检查和销毁连接池中空闲和无效的连接，直到剩余的连接数小于等于它的最小值。&lt;/p&gt;

&lt;p&gt;Java2D Disposer&lt;/p&gt;

&lt;p&gt;JVM&lt;/p&gt;

&lt;p&gt;这个线程主要服务于awt的各个组件。 说起该线程的主要工作职责前，需要先介绍一下Disposer类是干嘛的。 Disposer提供一个addRecord方法。 如果你想在一个对象被销毁前再做一些善后工作，那么，你可以调用Disposer#addRecord方法，将这个对象和一个自定义的DisposerRecord接口实现类，一起传入进去，进行注册。&lt;/p&gt;

&lt;p&gt;Disposer类会唤起“Java2D Disposer”线程，该线程会扫描已注册的这些对象是否要被回收了，如果是，则调用该对象对应的DisposerRecord实现类里面的dispose方法。&lt;/p&gt;

&lt;p&gt;Disposer实际上不限于在awt应用场景，只是awt里面的很多组件需要访问很多操作系统资源，所以，这些组件在被回收时，需要先释放这些资源。&lt;/p&gt;

&lt;p&gt;InsttoolCacheScheduler_QuartzSchedulerThread&lt;/p&gt;

&lt;p&gt;Quartz&lt;/p&gt;

&lt;p&gt;InsttoolCacheScheduler_QuartzSchedulerThread是Quartz的主线程，它主要负责实时的获取下一个时间点要触发的触发器，然后执行触发器相关联的作业 。&lt;/p&gt;

&lt;p&gt;原理大致如下：&lt;/p&gt;

&lt;p&gt;Spring和Quartz结合使用的场景下，Spring IOC容器初始化时会创建并初始化Quartz线程池（TreadPool），并启动它。刚启动时线程池中每个线程都处于等待状态，等待外界给他分配Runnable（持有作业对象的线程）。&lt;/p&gt;

&lt;p&gt;继而接着初始化并启动Quartz的主线程&lt;/p&gt;

&lt;p&gt;（InsttoolCacheScheduler_QuartzSchedulerThread），该线程自启动后就会处于等待状态。等待外界给出工作信号之后，该主线程的run方法才实质上开始工作。run中会获取JobStore中下一次要触发的作业，拿到之后会一直等待到该作业的真正触发时间，然后将该作业包装成一个JobRunShell对象（该对象实现了Runnable接口，其实看是上面TreadPool中等待外界分配给他的Runnable），然后将刚创建的JobRunShell交给线程池，由线程池负责执行作业。&lt;/p&gt;

&lt;p&gt;线程池收到Runnable后，从线程池一个线程启动Runnable，反射调用JobRunShell中的run方法，run方法执行完成之后， TreadPool将该线程回收至空闲线程中。&lt;/p&gt;

&lt;p&gt;InsttoolCacheScheduler_Worker-2&lt;/p&gt;

&lt;p&gt;Quartz&lt;/p&gt;

&lt;p&gt;InsttoolCacheScheduler_Worker-2线程就是ThreadPool线程的一个简单实现，它主要负责分配线程资源去执行&lt;/p&gt;

&lt;p&gt;InsttoolCacheScheduler_QuartzSchedulerThread线程交给它的调度任务（也就是JobRunShell）。&lt;/p&gt;

&lt;p&gt;JBossLifeThread&lt;/p&gt;

&lt;p&gt;Jboss&lt;/p&gt;

&lt;p&gt;Jboss主线程启动成功，应用程序部署完毕之后将JBossLifeThread线程实例化并且start，JBossLifeThread线程启动成功之后就处于等待状态，以保持Jboss Java进程处于存活中。  所得比较通俗一点，就是Jboss启动流程执行完毕之后，为什么没有结束？ 就是因为有这个线程hold主了它。&lt;/p&gt;

&lt;p&gt;JBoss System Threads(1)-1&lt;/p&gt;

&lt;p&gt;Jboss&lt;/p&gt;

&lt;p&gt;该线程是一个socket服务，默认端口号为： 1099。&lt;/p&gt;

&lt;p&gt;主要用于接收外部naming service（Jboss  JNDI）请求。&lt;/p&gt;

&lt;p&gt;JCA PoolFiller&lt;/p&gt;

&lt;p&gt;Jboss&lt;/p&gt;

&lt;p&gt;该线程主要为JBoss内部提供连接池的托管。&lt;/p&gt;

&lt;p&gt;简单介绍一下工作原理 ：&lt;/p&gt;

&lt;p&gt;Jboss内部凡是有远程连接需求的类，都需要实现&lt;/p&gt;

&lt;p&gt;ManagedConnectionFactory接口，例如需要做JDBC连接的&lt;/p&gt;

&lt;p&gt;XAManagedConnectionFactory对象，就实现了该接口。&lt;/p&gt;

&lt;p&gt;然后将XAManagedConnectionFactory对象，&lt;/p&gt;

&lt;p&gt;还有其它信息一起包装到&lt;/p&gt;

&lt;p&gt;InternalManagedConnectionPool&lt;/p&gt;

&lt;p&gt;对象里面，接着将&lt;/p&gt;

&lt;p&gt;InternalManagedConnectionPool&lt;/p&gt;

&lt;p&gt;交给PoolFiller对象里面的列队进行管理。&lt;/p&gt;

&lt;p&gt;JCA PoolFiller线程会定期判断列队内是否有需要创建和管理的&lt;/p&gt;

&lt;p&gt;InternalManagedConnectionPool&lt;/p&gt;

&lt;p&gt;对象，如果有的话，则调用该对象的fillToMin方法， 触发它去创建相应的远程连接，并且将这个连接维护到它相应的连接池里面去。&lt;/p&gt;

&lt;p&gt;JDWP Event Helper Thread&lt;/p&gt;

&lt;p&gt;JVM&lt;/p&gt;

&lt;p&gt;JDWP是通讯交互协议，它定义了调试器和被调试程序之间传递信息的格式。它详细完整地定义了请求命令、回应数据和错误代码，保证了前端和后端的JVMTI和JDI的通信通畅。  该线程主要负责将JDI事件映射成JVMTI信号，以达到调试过程中操作JVM的目的。&lt;/p&gt;

&lt;p&gt;JDWP Transport Listener:&lt;/p&gt;

&lt;p&gt;dt_socket&lt;/p&gt;

&lt;p&gt;JVM&lt;/p&gt;

&lt;p&gt;该线程是一个Java Debugger的监听器线程，负责受理客户端的debug请求。 通常我们习惯将它的监听端口设置为8787。&lt;/p&gt;

&lt;p&gt;Low Memory Detector&lt;/p&gt;

&lt;p&gt;JVM&lt;/p&gt;

&lt;p&gt;这个线程是负责对可使用内存进行检测，如果发现可用内存低，分配新的内存空间。&lt;/p&gt;

&lt;p&gt;process reaper&lt;/p&gt;

&lt;p&gt;JVM&lt;/p&gt;

&lt;p&gt;该线程负责去执行一个 OS 命令行的操作。&lt;/p&gt;

&lt;p&gt;Reference Handler&lt;/p&gt;

&lt;p&gt;JVM&lt;/p&gt;

&lt;p&gt;JVM在创建main线程后就创建Reference Handler线程，其优先级最高，为10，它主要用于处理引用对象本身（软引用、弱引用、虚引用）的垃圾回收问题 。&lt;/p&gt;

&lt;p&gt;Surrogate Locker Thread (CMS)&lt;/p&gt;

&lt;p&gt;JVM&lt;/p&gt;

&lt;p&gt;这个线程主要用于配合CMS垃圾回收器使用，它是一个守护线程，其主要负责处理GC过程中，Java层的Reference（指软引用、弱引用等等）与jvm 内部层面的对象状态同步。 这里对它们的实现稍微做一下介绍：这里拿 WeakHashMap做例子，将一些关键点先列出来（我们后面会将这些关键点全部串起来）：&lt;/p&gt;

&lt;p&gt;1.我们知道HashMap用Entry[]数组来存储数据的，WeakHashMap也不例外, 内部有一个Entry[]数组。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;WeakHashMap的Entry比较特殊，它的继承体系结构为&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Entry-&amp;gt;WeakReference-&amp;gt;Reference 。&lt;/p&gt;

&lt;p&gt;3.Reference 里面有一个全局锁对象：Lock，&lt;/p&gt;

&lt;p&gt;它也被称为pending_lock.注意：它是静态对象。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Reference  里面有一个静态变量：pending。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Reference里面有一个静态内部类：ReferenceHandler的线程，它在static块里面被初始化并且启动，启动完成后处于wait状态，它在一个Lock同步锁模块中等待。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;6.另外，WeakHashMap里面还实例化了一个ReferenceQueue列队，这个列队的作用，后面会提到。&lt;/p&gt;

&lt;p&gt;7.上面关键点就介绍完毕了，下面我们把他们串起来。&lt;/p&gt;

&lt;p&gt;假设，WeakHashMap对象里面已经保存了很多对象的引用。&lt;/p&gt;

&lt;p&gt;JVM 在进行CMS GC的时候，会创建一个ConcurrentMarkSweepThread（简称CMST）线程去进行GC，ConcurrentMarkSweepThread线程被创建的同时会创建一个SurrogateLockerThread（简称SLT）线程并且启动它，SLT启动之后，处于等待阶段。CMST开始GC时，会发一个消息给SLT让它去获取Java层Reference对象的全局锁：Lock。 直到CMS GC完毕之后，JVM 会将WeakHashMap中所有被回收的对象所属的WeakReference容器对象放入到Reference 的pending属性当中（每次GC完毕之后，pending属性基本上都不会为null了），然后通知SLT释放并且notify全局锁:Lock。此时激活了ReferenceHandler线程的run方法，使其脱离wait状态，开始工作了。ReferenceHandler这个线程会将pending中的所有WeakReference对象都移动到它们各自的列队当中，比如当前这个WeakReference属于某个WeakHashMap对象，那么它就会被放入相应的ReferenceQueue列队里面（该列队是链表结构）。 当我们下次从WeakHashMap对象里面get、put数据或者调用size方法的时候，WeakHashMap就会将ReferenceQueue列队中的WeakReference依依poll出来去和Entry[]数据做比较，如果发现相同的，则说明这个Entry所保存的对象已经被GC掉了，那么将Entry[]内的Entry对象剔除掉。&lt;/p&gt;

&lt;p&gt;taskObjectTimerFactory&lt;/p&gt;

&lt;p&gt;JVM&lt;/p&gt;

&lt;p&gt;顾名思义，该线程就是用来执行任务的。 当我们把一个认为交给Timer对象，并且告诉它执行时间，周期时间后，Timer就会将该任务放入任务列队，并且通知taskObjectTimerFactory线程去处理任务，taskObjectTimerFactory线程会将状态为取消的任务从任务列队中移除，如果任务是非重复执行类型的，则在执行完该任务后，将它从任务列队中移除，如果该任务是需要重复执行的，则计算出它下一次执行的时间点。&lt;/p&gt;

&lt;p&gt;VM Periodic Task Thread&lt;/p&gt;

&lt;p&gt;JVM&lt;/p&gt;

&lt;p&gt;该线程是JVM周期性任务调度的线程，它由WatcherThread创建，是一个单例对象。 该线程在JVM内使用得比较频繁，比如：定期的内存监控、JVM运行状况监控，还有我们经常需要去执行一些jstat 这类命令查看gc的情况，如下：&lt;/p&gt;

&lt;p&gt;jstat -gcutil 23483 250 7   这个命令告诉jvm在控制台打印PID为：23483的gc情况，间隔250毫秒打印一次，一共打印7次。&lt;/p&gt;

&lt;p&gt;VM Thread&lt;/p&gt;

&lt;p&gt;JVM&lt;/p&gt;

&lt;p&gt;这个线程就比较牛b了，是jvm里面的线程母体，根据hotspot源码（vmThread.hpp）里面的注释，它是一个单例的对象（最原始的线程）会产生或触发所有其他的线程，这个单个的VM线程是会被其他线程所使用来做一些VM操作（如，清扫垃圾等）。&lt;/p&gt;

&lt;p&gt;在 VMThread 的结构体里有一个VMOperationQueue列队，所有的VM线程操作(vm_operation)都会被保存到这个列队当中，VMThread 本身就是一个线程，它的线程负责执行一个自轮询的loop函数(具体可以参考：&lt;/p&gt;

&lt;p&gt;VMThread.cpp里面的&lt;/p&gt;

&lt;p&gt;void VMThread::loop()) ，该loop函数从VMOperationQueue列队中按照优先级取出当前需要执行的操作对象(VM_Operation)，&lt;/p&gt;

&lt;p&gt;并且调用VM_Operation-&amp;gt;evaluate函数去执行该操作类型本身的业务逻辑。&lt;/p&gt;

&lt;p&gt;ps：VM操作类型被定义在&lt;/p&gt;

&lt;p&gt;vm_operations.hpp文件内，列举几个：ThreadStop、&lt;/p&gt;

&lt;p&gt;ThreadDump、&lt;/p&gt;

&lt;p&gt;PrintThreads、&lt;/p&gt;

&lt;p&gt;GenCollectFull、GenCollectFullConcurrent、CMS_Initial_Mark、CMS_Final_Remark…..&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Comparison between HTTP1 and HTTP2</title>
      <link>http://danigong.github.io/post/A_Comparison_between_HTTP1_and_HTTP2/</link>
      <pubDate>Tue, 13 Mar 2018 16:17:16 +0800</pubDate>
      
      <guid>http://danigong.github.io/post/A_Comparison_between_HTTP1_and_HTTP2/</guid>
      <description>&lt;p&gt;&lt;strong&gt;&lt;code&gt;HTTP1.1 HTTP 2.0&lt;/code&gt;主要区别&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;多路复用&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;HTTP2.0&lt;/code&gt;使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比&lt;code&gt;HTTP1.1&lt;/code&gt;大了好几个数量级。当然&lt;code&gt;HTTP1.1&lt;/code&gt;也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。TCP连接有一个预热和保护的过程，先检查数据是否传送成功，一旦成功过，则慢慢加大传输速度。因此对应瞬时并发的连接，服务器的响应就会变慢。所以最好能使用一个建立好的连接，并且这个连接可以支持瞬时并发的请求。
关于多路复用，可以参看&lt;a href=&#34;http://blog.csdn.net/linsongbin1/article/details/54865371&#34;&gt;学习NIO&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;数据压缩&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;HTTP1.1&lt;/code&gt;不支持header数据的压缩，&lt;code&gt;HTTP2.0&lt;/code&gt;使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;服务器推送&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;意思是说，当我们对支持&lt;code&gt;HTTP2.0&lt;/code&gt;的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。服务器端推送的这些资源其实存在客户端的某处地方，客户端直接从本地加载这些资源就可以了，不用走网络，速度自然是快很多的。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Fluent Python Reading Notes</title>
      <link>http://danigong.github.io/fp_reading_notes/</link>
      <pubDate>Mon, 12 Mar 2018 15:29:43 +0800</pubDate>
      
      <guid>http://danigong.github.io/fp_reading_notes/</guid>
      <description>

&lt;h3 id=&#34;1:5f871522afb4c8f73815d5199dd60799&#34;&gt;1&lt;/h3&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dict()&lt;/code&gt; is slower than &lt;code&gt;{}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;list()&lt;/code&gt; is slower than &lt;code&gt;()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;[x] 需要符号查找（不能预先知道&lt;code&gt;list()&lt;/code&gt;有没有被重定义）&lt;/li&gt;
&lt;li&gt;[x] 方法调用&lt;/li&gt;
&lt;li&gt;[x] 要检查有没有可迭代变量传入&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;2:5f871522afb4c8f73815d5199dd60799&#34;&gt;2&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;特殊方法&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__len__()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__getitem__()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__setitem__()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__iter__()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;是为了被&lt;code&gt;python解释器&lt;/code&gt;调用的，自己不用调用它们，所以没有&lt;code&gt;A.__len__()&lt;/code&gt;方法，只有&lt;code&gt;len(A)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;3:5f871522afb4c8f73815d5199dd60799&#34;&gt;3&lt;/h3&gt;

&lt;p&gt;自定义布尔值 -&amp;gt; 实现&lt;code&gt;__bool__&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;4:5f871522afb4c8f73815d5199dd60799&#34;&gt;4&lt;/h3&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__str__()&lt;/code&gt; : readable, 面向用户&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__repr__()&lt;/code&gt; : unambigous, 面向DEV&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;5:5f871522afb4c8f73815d5199dd60799&#34;&gt;5&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;The Zen of Python&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1. 实用胜于纯粹&lt;/li&gt;
&lt;li&gt;2. 不能让特例特殊到开始破坏规则&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;6:5f871522afb4c8f73815d5199dd60799&#34;&gt;6&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;内置序列类型&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;容器序列：任意类型，引用 - &lt;code&gt;list, tuple, deque&lt;/code&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;扁平序列：单一类型，值 － &lt;code&gt;str(3.0), byte(3.0), bytearray, memoryview&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;可变序列(MutableSequence)：&lt;code&gt;list, deque&lt;/code&gt; &amp;hellip;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不可变序列(Sequence)：&lt;code&gt;tuple, str, byte&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;7:5f871522afb4c8f73815d5199dd60799&#34;&gt;7&lt;/h3&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;list comprehension = listcomps 列表推导&lt;/li&gt;
&lt;li&gt;generator expression = genexps 生成器表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;8:5f871522afb4c8f73815d5199dd60799&#34;&gt;8&lt;/h3&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;chr(65)&lt;/code&gt; -&amp;gt; A&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ord(A)&lt;/code&gt; -&amp;gt; 65&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unichr(12345)&lt;/code&gt; -&amp;gt; u&amp;rsquo;\u3039&amp;rsquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;9:5f871522afb4c8f73815d5199dd60799&#34;&gt;9&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;列表推导的作用只有一个：&lt;/strong&gt; 生成列表&lt;/p&gt;

&lt;h3 id=&#34;10:5f871522afb4c8f73815d5199dd60799&#34;&gt;10&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;genexps&lt;/code&gt;优于&lt;code&gt;listcomps&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;genexps&lt;/code&gt;遵守了迭代器协议，可以逐个产生元素，而不是先建立一个完整的列表，避免了额外的内存占用&lt;/p&gt;

&lt;h3 id=&#34;11:5f871522afb4c8f73815d5199dd60799&#34;&gt;11&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;元组拆包&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;a,b = (a,b)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a,b = b,a&lt;/code&gt; 两个变量值交换&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;12:5f871522afb4c8f73815d5199dd60799&#34;&gt;12&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;*&lt;/code&gt;来处理剩下的元素&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Python3: &lt;strong&gt;平行赋值&lt;/strong&gt;: &lt;code&gt;a,b,*rest = range(5)&lt;/code&gt; -&amp;gt; &lt;code&gt;(0,1,[2,3,4])&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;13:5f871522afb4c8f73815d5199dd60799&#34;&gt;13&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;namedtuple&lt;/code&gt;和&lt;code&gt;tuple&lt;/code&gt;创建实例消耗内存一样，因为字段名都存在类里：&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_fileds&lt;/code&gt;类属性&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_make(iterable)&lt;/code&gt;类方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_asdict()&lt;/code&gt;实例方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;14:5f871522afb4c8f73815d5199dd60799&#34;&gt;14&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;tuple&lt;/code&gt;没有&lt;code&gt;__reversed__&lt;/code&gt;方法，但可以&lt;code&gt;reversed(my_tuple)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;15:5f871522afb4c8f73815d5199dd60799&#34;&gt;15&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;切片赋值&lt;/strong&gt;：改变&lt;code&gt;list&lt;/code&gt;中连续多个值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    l = list(range(10))
    l[2:5] = [20,30]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-&amp;gt; &lt;code&gt;l:[0,1,20,30,5,6,7,8,9]&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;16:5f871522afb4c8f73815d5199dd60799&#34;&gt;16&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;__iadd__&lt;/code&gt;方法：就地加法&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt; = &lt;code&gt;__iadd__&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; = &lt;code&gt;__imul__&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;17:5f871522afb4c8f73815d5199dd60799&#34;&gt;17&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;id(object)&lt;/code&gt; -&amp;gt; return &amp;ldquo;Identity(内存地址)&amp;rdquo; of an object&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+=&lt;/code&gt; or &lt;code&gt;*=&lt;/code&gt; 用在&lt;code&gt;list&lt;/code&gt;上，不改变id&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+=&lt;/code&gt; or &lt;code&gt;*=&lt;/code&gt; 用在&lt;code&gt;tuple&lt;/code&gt;上，改变id，重新创建一个obj&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;18:5f871522afb4c8f73815d5199dd60799&#34;&gt;18&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;如果一个方法对对象进行的是就地改动，那就应该返回&lt;code&gt;None&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;19:5f871522afb4c8f73815d5199dd60799&#34;&gt;19&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;list.sort&lt;/code&gt; -&amp;gt; 就地改&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sorted()&lt;/code&gt; -&amp;gt; 新建一个列表返回&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Example:
&lt;code&gt;sorted(fruits, key=len)&lt;/code&gt;
&lt;code&gt;sorted(fruits, key=lower)&lt;/code&gt; &amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;20:5f871522afb4c8f73815d5199dd60799&#34;&gt;20&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;bisect&lt;/code&gt; 二分查找&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1. &lt;code&gt;bisect(haystack, needle)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;2. &lt;code&gt;insort(seq, item)&lt;/code&gt; -&amp;gt; 插入后仍保持升序&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;21:5f871522afb4c8f73815d5199dd60799&#34;&gt;21&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;字符串格式化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&#39; &#39;.format(a,b,c)&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;{0}&lt;/code&gt; -&amp;gt; 位置参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{name}&lt;/code&gt; -&amp;gt; 关键字参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{0[0]}&lt;/code&gt; -&amp;gt; 对&lt;code&gt;list&lt;/code&gt;使用索引&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{0:*(填充字符)&amp;gt;(右对齐)10(宽度)}&lt;/code&gt; -&amp;gt; 填充与格式化&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;22:5f871522afb4c8f73815d5199dd60799&#34;&gt;22&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;array&lt;/code&gt; 场景-&amp;gt;1000万个浮点数
&lt;code&gt;deque&lt;/code&gt; 场景-&amp;gt;需要频繁对序列进行&lt;code&gt;FIFO&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;23:5f871522afb4c8f73815d5199dd60799&#34;&gt;23&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;memoryview&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;24:5f871522afb4c8f73815d5199dd60799&#34;&gt;24&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;numpy, scipy&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;25:5f871522afb4c8f73815d5199dd60799&#34;&gt;25&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;collections.deque&lt;/code&gt;&lt;/strong&gt;：线程安全、快速从两端添加、删除元素。&lt;/p&gt;

&lt;p&gt;*场景*：存放最近使用的几个元素&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1. &lt;code&gt;rotate(3)&lt;/code&gt;：右边三个到左边。&lt;code&gt;rotate(-4)&lt;/code&gt;：左边四个到右边。&lt;/li&gt;
&lt;li&gt;2. &lt;code&gt;appendleft()&lt;/code&gt;：单个。&lt;code&gt;extend, extendleft&lt;/code&gt;： 队列。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;26:5f871522afb4c8f73815d5199dd60799&#34;&gt;26&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;散列表&lt;/code&gt;&lt;/strong&gt;是&lt;code&gt;字典&lt;/code&gt;类型性能出众的根本原因。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;collections.abc.Mapping&lt;/code&gt;的instance&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原子不可变数据类型&lt;/strong&gt;（&lt;code&gt;str, byte&lt;/code&gt;和数值类型）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;散列值&lt;/strong&gt;就是&lt;code&gt;id()&lt;/code&gt;函数的返回值&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;27:5f871522afb4c8f73815d5199dd60799&#34;&gt;27&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;字典创建方法&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1. &lt;code&gt;a = dict(one=1,two=2,three=3)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;2. &lt;code&gt;b = {&#39;one&#39;:1,&#39;two&#39;:2,&#39;three&#39;:3}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;3. &lt;code&gt;c = dict(zip([&#39;one&#39;,&#39;two&#39;,&#39;three&#39;],[1,2,3]))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;4. 字典推导 &lt;code&gt;dictcomp&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;28:5f871522afb4c8f73815d5199dd60799&#34;&gt;28&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;dict.setdefault&lt;/code&gt;&lt;/strong&gt;处理不存在于&lt;code&gt;dict&lt;/code&gt;中的&lt;code&gt;key&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;29:5f871522afb4c8f73815d5199dd60799&#34;&gt;29&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;collections.defaultdict&lt;/code&gt;&lt;/strong&gt;是处理找不到&lt;code&gt;key&lt;/code&gt;的一个选择&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dd = defautdict(list)&lt;/code&gt;，如果&lt;code&gt;&#39;new-key&#39;&lt;/code&gt;不存在，&lt;code&gt;dd[&#39;new-key&#39;]&lt;/code&gt;会执行：&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1. &lt;code&gt;list()&lt;/code&gt;建新列表&lt;/li&gt;
&lt;li&gt;2. 这个新列表作为&lt;code&gt;值&lt;/code&gt;，&lt;code&gt;new-key&lt;/code&gt;为&lt;code&gt;key&lt;/code&gt;，放入&lt;code&gt;dd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;3. 返回这个列表的引用&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;30:5f871522afb4c8f73815d5199dd60799&#34;&gt;30&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;__missing__&lt;/code&gt;只会被&lt;code&gt;__getitem__&lt;/code&gt;调用&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;31:5f871522afb4c8f73815d5199dd60799&#34;&gt;31&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;如果要自定义一个映射类型，应该继承&lt;code&gt;collections.UserDict&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;32:5f871522afb4c8f73815d5199dd60799&#34;&gt;32&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;字典的变种&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1. &lt;code&gt;collections.OrderedDict&lt;/code&gt;: &lt;code&gt;popitem&lt;/code&gt;方法 -&amp;gt; 删除并返回&lt;/li&gt;
&lt;li&gt;2. &lt;code&gt;collections.ChainMap&lt;/code&gt;: 多个字典逐个查找&lt;/li&gt;
&lt;li&gt;3. &lt;code&gt;collections.Counter&lt;/code&gt;:&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;    ct = Counter(&#39;abracadabra&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;-&amp;gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;    Counter({&#39;a&#39;:5,&#39;b&#39;:2,&#39;r&#39;:2,&#39;c&#39;:1,&#39;d&#39;:1})
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;4. &lt;code&gt;UserDict&lt;/code&gt;用户涌来继承写子类&lt;/li&gt;
&lt;li&gt;5. &lt;code&gt;TransformDict&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;33:5f871522afb4c8f73815d5199dd60799&#34;&gt;33&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;不可变映射类型&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;types.MappingProxyType&lt;/code&gt;：&lt;code&gt;只读的映射视图&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;34:5f871522afb4c8f73815d5199dd60799&#34;&gt;34&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;set&lt;/code&gt; -&amp;gt; 许多唯一对象的聚集；&lt;code&gt;frozenset&lt;/code&gt; -&amp;gt; 不可变&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;集合&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1. 用于去重复：&lt;code&gt;list&lt;/code&gt; -&amp;gt; &lt;code&gt;set&lt;/code&gt; -&amp;gt; &lt;code&gt;list&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;2. 合集，交集，差集 -&amp;gt; 场景：元素出现次数&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;如果是空集必须写成&lt;code&gt;set()&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;35:5f871522afb4c8f73815d5199dd60799&#34;&gt;35&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;散列表&lt;/strong&gt;：稀疏数组（总有空白元素的数组）
&lt;code&gt;key:value&lt;/code&gt; -&amp;gt; 一个&lt;code&gt;表元&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;因为所有表元大小一致，所以可以通过&lt;code&gt;偏移量&lt;/code&gt;来读取某个表元&lt;/p&gt;

&lt;p&gt;用&lt;code&gt;hash()&lt;/code&gt;来计算&lt;code&gt;散列值&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;36:5f871522afb4c8f73815d5199dd60799&#34;&gt;36&lt;/h3&gt;

&lt;p&gt;存放数量巨大的记录用&lt;code&gt;tuple&lt;/code&gt;或&lt;code&gt;namedtuple&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dict&lt;/code&gt; 散列 -&amp;gt; 内存消耗大&lt;/p&gt;

&lt;h3 id=&#34;37:5f871522afb4c8f73815d5199dd60799&#34;&gt;37&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/strong&gt;：&lt;strong&gt;空间&lt;/strong&gt;换&lt;strong&gt;时间&lt;/strong&gt; -&amp;gt; &lt;strong&gt;读取快&lt;/strong&gt; 但 &lt;strong&gt;内存消耗大&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Python解释器可能为字典扩容 -&amp;gt; 导致新建一个更大的散列表&lt;/p&gt;

&lt;h3 id=&#34;38:5f871522afb4c8f73815d5199dd60799&#34;&gt;38&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;集合 &lt;code&gt;set&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1. 元素必须可散列&lt;/li&gt;
&lt;li&gt;2. 很耗内存&lt;/li&gt;
&lt;li&gt;3. 高效查找&lt;/li&gt;
&lt;li&gt;4. 次序取决于添加次序&lt;/li&gt;
&lt;li&gt;5. 添加元素可能改变已有元素次序(*37*中的扩容)&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;39:5f871522afb4c8f73815d5199dd60799&#34;&gt;39&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;字符&lt;/strong&gt;的最佳定义是&lt;code&gt;Unicode&lt;/code&gt;字符&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Python3&lt;/code&gt; 从 &lt;code&gt;str&lt;/code&gt;对象中获取的元素是&lt;code&gt;Unicode&lt;/code&gt;字符&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;字符的具体表述取决于所用的编码&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;编码：码位 -&amp;gt; 字节序列&lt;/li&gt;
&lt;li&gt;解码：字节序列 -&amp;gt; 码位（字符的标识）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;40:5f871522afb4c8f73815d5199dd60799&#34;&gt;40&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;字面量&lt;/strong&gt;：双眼所见&lt;/p&gt;

&lt;h3 id=&#34;41:5f871522afb4c8f73815d5199dd60799&#34;&gt;41&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;utf_8&lt;/code&gt; 的别名：&lt;code&gt;utf8&lt;/code&gt;, &lt;code&gt;u8&lt;/code&gt;, &lt;code&gt;utf-8&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;42:5f871522afb4c8f73815d5199dd60799&#34;&gt;42&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;编码种类&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;latin1&lt;/code&gt;(iso8859-1)：是其他编码的基础&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cp1252&lt;/code&gt;：Windows制定的&lt;code&gt;latin1&lt;/code&gt;的超集，添加了有用的符号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gb2312&lt;/code&gt;：用于编码简体中文的&lt;strong&gt;陈旧&lt;/strong&gt;标准&lt;/li&gt;
&lt;li&gt;&lt;code&gt;utf-8&lt;/code&gt;：web最常见的8位编码，与&lt;code&gt;ASCII&lt;/code&gt;兼容&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;43:5f871522afb4c8f73815d5199dd60799&#34;&gt;43&lt;/h3&gt;

&lt;p&gt;Python3 中默认使用 &lt;code&gt;utf8&lt;/code&gt; 编码源码&lt;/p&gt;

&lt;h3 id=&#34;44:5f871522afb4c8f73815d5199dd60799&#34;&gt;44&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;判断编码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以下是肉眼方法&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1. &lt;code&gt;HTTP&lt;/code&gt;和&lt;code&gt;XML&lt;/code&gt;，包含明确指明内容编码的&lt;em&gt;首部&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;2. 包含大于127的字节值，那么就不是ASCII&lt;/li&gt;
&lt;li&gt;3. 如果 &lt;code&gt;b&#39;\x00&#39;&lt;/code&gt; 经常出现，那么就不是8位编码方案&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;统一字符编码侦测包：&lt;code&gt;Chardet&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;45:5f871522afb4c8f73815d5199dd60799&#34;&gt;45&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Python中，函数是一等对象&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1. 运行时创建&lt;/li&gt;
&lt;li&gt;2. 能赋值给变量或数据结构中的元素&lt;/li&gt;
&lt;li&gt;3. 能作为参数传给函数&lt;/li&gt;
&lt;li&gt;4. 能被&lt;code&gt;return&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;46:5f871522afb4c8f73815d5199dd60799&#34;&gt;46&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;__doc__&lt;/code&gt;用于生成对象的帮助文本&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;47:5f871522afb4c8f73815d5199dd60799&#34;&gt;47&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;函数式编程&lt;/strong&gt;：特点之一是使用高阶函数&lt;/p&gt;

&lt;p&gt;高阶函数：&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1. 接受函数作为参数&lt;/li&gt;
&lt;li&gt;&lt;em&gt;或&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;2. 把函数作为结果返回&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;48:5f871522afb4c8f73815d5199dd60799&#34;&gt;48&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;map, filter 和 reduce&lt;/code&gt; 在Python3中已经不是内置函数
被 &lt;code&gt;listcomps&lt;/code&gt; 和 &lt;code&gt;genexps&lt;/code&gt; 所替代（可读性原因）&lt;/p&gt;

&lt;h3 id=&#34;49:5f871522afb4c8f73815d5199dd60799&#34;&gt;49&lt;/h3&gt;

&lt;p&gt;匿名函数：&lt;code&gt;lambda&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;50:5f871522afb4c8f73815d5199dd60799&#34;&gt;50&lt;/h3&gt;

&lt;p&gt;使用&lt;code&gt;callable()&lt;/code&gt;函数来判断一个对象能否调用&lt;/p&gt;

&lt;h3 id=&#34;51:5f871522afb4c8f73815d5199dd60799&#34;&gt;51&lt;/h3&gt;

&lt;p&gt;用户定义可调用类型，只需实现实例方法&lt;code&gt;__call__&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;52:5f871522afb4c8f73815d5199dd60799&#34;&gt;52&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;函数内省&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;53:5f871522afb4c8f73815d5199dd60799&#34;&gt;53&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;函数有但一般对象没有的特殊方法：&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__annotations__&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__call__&lt;/code&gt;：实现&lt;code&gt;()&lt;/code&gt;运算符&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;54:5f871522afb4c8f73815d5199dd60799&#34;&gt;54&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;函数注解&lt;/strong&gt;只存放在&lt;code&gt;__annotations__&lt;/code&gt;属性里，Python不做检查、验证、强制&amp;hellip;&lt;/p&gt;

&lt;p&gt;注解只是元数据，可以供IDE、框架和装饰器工具使用&lt;/p&gt;

&lt;h3 id=&#34;55:5f871522afb4c8f73815d5199dd60799&#34;&gt;55&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;函数式编程&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1. &lt;code&gt;operator&lt;/code&gt; -&amp;gt; &lt;code&gt;itemgetter&lt;/code&gt;(get下标)，&lt;code&gt;attrgetter&lt;/code&gt;(get name)&lt;/li&gt;
&lt;li&gt;2. &lt;code&gt;functools&lt;/code&gt; 内包含 &lt;code&gt;reduce&lt;/code&gt;函数，&lt;code&gt;partial&lt;/code&gt;冻结参数，&lt;code&gt;partialmethod&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;Example:&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;    triple = partial(mul,3)
    triple(7) -&amp;gt; 21
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;56:5f871522afb4c8f73815d5199dd60799&#34;&gt;56&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;globals()&lt;/code&gt; &lt;strong&gt;策略模式&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;57:5f871522afb4c8f73815d5199dd60799&#34;&gt;57&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;命令模式&lt;/strong&gt;：是回调机制的面向对象替代品&lt;/p&gt;

&lt;h3 id=&#34;58:5f871522afb4c8f73815d5199dd60799&#34;&gt;58&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;nonlocal&lt;/code&gt;关键字。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;装饰器&lt;/strong&gt; 目的是增强函数&lt;/p&gt;

&lt;h3 id=&#34;59:5f871522afb4c8f73815d5199dd60799&#34;&gt;59&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;元编程&lt;/strong&gt; -&amp;gt; 在运行时改变程序的行为&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;装饰器的两大特性&lt;/strong&gt;：&lt;/p&gt;

&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1. 能把装饰的函数替换成其他函数&lt;/li&gt;
&lt;li&gt;2. 在加载模块时立即执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;60:5f871522afb4c8f73815d5199dd60799&#34;&gt;60&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;装饰器&lt;/strong&gt; 在被装饰的函数定义之后立即运行。通常是在导入时（加载模块时）&lt;/p&gt;

&lt;h3 id=&#34;61:5f871522afb4c8f73815d5199dd60799&#34;&gt;61&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;变量作用域规则&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    b = 6
    def f2(a):
        print(a)
        print(b)
        b = 9
    
    f2(3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出 &lt;code&gt;3&lt;/code&gt;, &lt;code&gt;local variable &#39;b&#39; referenced before assignment&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Python编译函数定义体时，它判断&lt;code&gt;b&lt;/code&gt;是局部变量，因为在函数中给它赋值了。生成的字节码证实了这种判断，Python会尝试从本地环境获取&lt;code&gt;b&lt;/code&gt;。后面调用&lt;code&gt;f2(3)&lt;/code&gt;时，&lt;code&gt;f2&lt;/code&gt;的定义体会获取并打印局部变量&lt;code&gt;a&lt;/code&gt;的值，但是尝试获取局部变量&lt;code&gt;b&lt;/code&gt;的值时，发现&lt;code&gt;b&lt;/code&gt;没有绑定值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这不是缺陷&lt;/strong&gt;，而是&lt;strong&gt;设计选择&lt;/strong&gt;：Python不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量。&lt;/p&gt;

&lt;p&gt;如果在函数中赋值时想让解释器把&lt;code&gt;b&lt;/code&gt;当成全局变量，要使用&lt;code&gt;global&lt;/code&gt;声明。&lt;/p&gt;

&lt;h3 id=&#34;62:5f871522afb4c8f73815d5199dd60799&#34;&gt;62&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;闭包&lt;/strong&gt; 不等同于 &lt;strong&gt;匿名函数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;闭包是延伸了作用域的函数&lt;/strong&gt;，函数是不是匿名的没有关系，关键是它能否访问定义体&lt;strong&gt;之外&lt;/strong&gt;定义的&lt;strong&gt;非&lt;/strong&gt;全局变量&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Jmeter Thread Group</title>
      <link>http://danigong.github.io/post/Jmeter_Thread_Group/</link>
      <pubDate>Sun, 11 Mar 2018 15:17:57 +0800</pubDate>
      
      <guid>http://danigong.github.io/post/Jmeter_Thread_Group/</guid>
      <description>&lt;p&gt;&lt;strong&gt;1、Action to be take after a Sampler error&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Continue&lt;/code&gt;：忽略错误，继续执行操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Start Next Thread Loop&lt;/code&gt;：忽略错误，线程当前循环终止，执行下一个循环&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Stop Thread&lt;/code&gt;：停止当前线程，其他线程不受影响&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Stop Test&lt;/code&gt;：当前执行的采样器结束后，停止整个测试计划&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Stop Test Now&lt;/code&gt;：立即停止整个测试计划&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2、Thread Properties&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Number of Threads(users)&lt;/code&gt;：当前线程数量，可以简单的理解为用户数量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ramp-up Period (in seconds)&lt;/code&gt;：达到上面指定线程数所花费的时间，单位为秒。举个栗子：假设线程数为100个，花费时间20s，那么每秒启动的线程数 = 线程数/时间，即100/20 = 5。换句话说，就是1秒启动5个线程。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Loop Count&lt;/code&gt;：勾选“永远”选项，则线程组一直循环。否则，以后面所填数量为准。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Delay Thread creation until needed&lt;/code&gt;：当线程需要执行的时候，才会被创建。如果不勾选此选项，所有线程在开始时就全部被创建。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Scheduler&lt;/code&gt;：勾选此选项，才可修改下面的调度器配置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3、Scheduler Configuration&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Duration(seconds)&lt;/code&gt;：整个测试计划持续的时间。（优先于后面的结束时间选项)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Startup delay(seconds)&lt;/code&gt;：测试计划启动后，会被延迟启动，时间为选项填入的时间。（优先于后面的启动时间选项）&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Why nGrinder?</title>
      <link>http://danigong.github.io/post/Why_nGrinder/</link>
      <pubDate>Fri, 09 Mar 2018 16:36:55 +0800</pubDate>
      
      <guid>http://danigong.github.io/post/Why_nGrinder/</guid>
      <description>&lt;p&gt;nGrinder与其他工具比较&amp;ndash;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;JMeter&lt;/strong&gt;
基于UI操作，容易上手，但是不具备编程能力。其次JMeter基于线程模拟数千用户几乎不可能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tsung&lt;/strong&gt;
基于Erlang，能模拟上千用户并且易于扩展。但是基于XML的DSL，描述场景能力弱，而且需要大量的数据处理才知道测试结果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Locust&lt;/strong&gt;
基于python的gevent，能模拟百万个用户。但是需要对python有一定理解。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Loadrunner&lt;/strong&gt;
这个可以说是应用最多的一个，很方便，但是还是太重。往后的方向肯定是客户端工具逐步向平台化发展，所以loadrunner注定慢慢被淘汰（个人拙见）。而且不开源，扩展性不高，收费。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;nGrinder&lt;/strong&gt;
单节点支持3000并发、支持分布式、可监控被测服务器、可录制脚本、开源、平台化。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Show all files in finder</title>
      <link>http://danigong.github.io/post/Show_all_files_in_finder/</link>
      <pubDate>Thu, 08 Mar 2018 14:37:42 +0800</pubDate>
      
      <guid>http://danigong.github.io/post/Show_all_files_in_finder/</guid>
      <description>&lt;p&gt;如何在Mac OS X中开启或关闭显示隐藏文件命令&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;可以这样：&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;defaults write com.apple.finder AppleShowAllFiles -bool true&lt;/code&gt;      - 此命令显示隐藏文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;defaults write com.apple.finder AppleShowAllFiles -bool false&lt;/code&gt;     - 此命令关闭显示隐藏文件&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;命令运行之后需要重新加载Finder：快捷键&lt;code&gt;option+command+esc&lt;/code&gt;，选中Finder，重新启动即可&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;或者这样：&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;defaults write com.apple.finder AppleShowAllFiles FALSE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;killall Finder&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Force empty trash</title>
      <link>http://danigong.github.io/post/Force_empty_trash/</link>
      <pubDate>Thu, 08 Mar 2018 14:18:34 +0800</pubDate>
      
      <guid>http://danigong.github.io/post/Force_empty_trash/</guid>
      <description>&lt;p&gt;&lt;strong&gt;可以这样&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;sudo rm -rf ~/.Trash/&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>How to create a github.io repo</title>
      <link>http://danigong.github.io/post/how_to_create_a_github_io_repo/</link>
      <pubDate>Wed, 07 Mar 2018 17:09:40 +0800</pubDate>
      
      <guid>http://danigong.github.io/post/how_to_create_a_github_io_repo/</guid>
      <description>&lt;p&gt;&lt;strong&gt;开通自己的github.io repo&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;github.io是完全基于github创建的，其本质上是在你的github账户下创建一个特殊的repo。你可以参照如下步骤完成：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;创建repo&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当然，一切的前提是你得首先有个github的账户，这里还请自行解决。登陆你的账户后，你可以创建一个新的repo。请务必注意该repo的名字，必须保持格式&lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt;，其中&lt;code&gt;&amp;lt;username&amp;gt;&lt;/code&gt;替换成你的github账户名，这里假定创建的repo为 &amp;gt; &lt;code&gt;danielgong.github.io&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;把你创建的repo clone到本地就可以了&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git clone https://github.com/tobiasalin/tobiasalin.github.io&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to update hugo blog</title>
      <link>http://danigong.github.io/post/how_to_update_hugo_blog/</link>
      <pubDate>Wed, 07 Mar 2018 16:45:07 +0800</pubDate>
      
      <guid>http://danigong.github.io/post/how_to_update_hugo_blog/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Quick Start&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1. Open iTerm2&lt;/li&gt;
&lt;li&gt;2. &lt;code&gt;control+command+h&lt;/code&gt; to open the tab with hugo profile&lt;/li&gt;
&lt;li&gt;3. &lt;code&gt;addblog&lt;/code&gt; to create a new blog post, hugo command will create a new post tesmplate and subl command will help open it.&lt;/li&gt;
&lt;li&gt;4. Note: Blog Title should not contain space and strip out &lt;code&gt;menu = &amp;quot;main&amp;quot;&lt;/code&gt; in the template.&lt;/li&gt;
&lt;li&gt;5. &lt;code&gt;deployblog&lt;/code&gt; to deploy newest update to github.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Detail&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;create blog shell script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &amp;quot;Blog Title: &amp;quot;
read Title
cd /Users/DanielGong/HugoSite/testsite
hugo new post/$Title.md
subl /Users/DanielGong/HugoSite/testsite/content/post/$Title.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;eploy blog shell script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;echo &amp;quot;-------Begin-------&amp;quot;

cd /Users/DanielGong/HugoSite/testsite
hugo --theme=gs-hyde --baseUrl=&amp;quot;http://danigong.github.io/&amp;quot;
cd public
git add -A
git commit -m &amp;quot;auto_commit&amp;quot;
git push origin master

echo &amp;quot;-------Done-------&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;customize command:&lt;/p&gt;

&lt;p&gt;Add &lt;code&gt;alias addblog=&amp;quot;xxx.sh&amp;quot;&lt;/code&gt; into &lt;code&gt;.bashrc&lt;/code&gt; file. Then &lt;code&gt;source ~/.bashrc&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Markdown Online Editor</title>
      <link>http://danigong.github.io/post/markdown_online_editor/</link>
      <pubDate>Wed, 07 Mar 2018 11:25:30 +0800</pubDate>
      
      <guid>http://danigong.github.io/post/markdown_online_editor/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Online Markdown Language Editor&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Visit: &lt;a href=&#34;https://www.zybuluo.com/mdeditor&#34;&gt;https://www.zybuluo.com/mdeditor&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The best django project structure</title>
      <link>http://danigong.github.io/post/The-best-django-project-structure/</link>
      <pubDate>Mon, 05 Mar 2018 11:01:39 +0800</pubDate>
      
      <guid>http://danigong.github.io/post/The-best-django-project-structure/</guid>
      <description>

&lt;h1 id=&#34;项目目录结构:dfe114c833a99a64f54e2cfb47175ca9&#34;&gt;项目目录结构&lt;/h1&gt;

&lt;p&gt;在上一节里我们使用Django的django-admin startproject命令来创建了一个Helloworld的项目，在没有写任何代码的情况下成功运行了这个项目。虽然目前来说这个项目没有任何功能，但是这是我们一个成功的开始，不是吗？&lt;/p&gt;

&lt;h3 id=&#34;helloworld项目的目录结构:dfe114c833a99a64f54e2cfb47175ca9&#34;&gt;Helloworld项目的目录结构&lt;/h3&gt;

&lt;p&gt;我们来看一下这个项目的目录结构&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zhiwehu.gitbooks.io/build-web-application-with-python-django/content/assets/Helloworld project directory structure.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最外层的Helloworld目录，是项目的根目录，在这个目录下我们看到有2个文件，一个是&lt;code&gt;db.sqlite3&lt;/code&gt;是数据库文件，另一个是&lt;code&gt;manage.py&lt;/code&gt;是Django提供的一个管理工具入口，比如上一节中我们使用python manage.py runserver来运行这个web app。
根目录下面的Helloworld目录，是项目的配置目录，里面放了Django的一些配置信息，包括一个&lt;code&gt;settings.py&lt;/code&gt;，一个根&lt;code&gt;urls.py&lt;/code&gt;和&lt;code&gt;wsgi.py&lt;/code&gt;，这些都是Django运行所需要的配置性文件。
还有一个firstapp是我使用&lt;code&gt;django-admin startapp firstapp&lt;/code&gt;这个命令创建的一个app，这相当是这个项目的一个功能性的app，Django使用app来划分模块。
这个项目目录结构好吗？
虽然我们使用了Django提供的django-admin创建的项目目录结构看起来很简单明了，但是我们应该知道，这只是供学习使用的，在真正的项目里，估计就没有人这样使用了。一个真实的产品项目，我们需要有更多的配置信息、文档、测试等，以及代码仓库配置等。而这个简单的目录结构显然是达不到这样的要求的。&lt;/p&gt;

&lt;h3 id=&#34;推荐的项目目录结构:dfe114c833a99a64f54e2cfb47175ca9&#34;&gt;推荐的项目目录结构&lt;/h3&gt;

&lt;p&gt;在本节里我重点是要介绍一个我认为是最佳的Django项目目录结构，当然所谓的『最佳』因人而异，我同时也会提供其他的一些选项供参考。接下来看一下这个&lt;strong&gt;目录结构&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://zhiwehu.gitbooks.io/build-web-application-with-python-django/content/assets/The best django project directory structure.png&#34; alt=&#34;tool-manager&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;接下来我详细说明一下这个目录结构:dfe114c833a99a64f54e2cfb47175ca9&#34;&gt;接下来我详细说明一下这个目录结构&lt;/h3&gt;

&lt;p&gt;最外层的project是项目根目录，这个目录除了之前的manage.py这个文件外，还有更多的配置文件，和其他子目录。这些配置文件后面会详细介绍。
config目录是配置目录，里面除了包含了根&lt;code&gt;urls.py&lt;/code&gt;文件和&lt;code&gt;wsgi.py&lt;/code&gt;文件，我们将原来的&lt;code&gt;settings.py&lt;/code&gt;扩展成为了一个Python package，因为我们在不同的环境中将使用不同的配置文件，在本地电脑上使用&lt;code&gt;settings.local.py&lt;/code&gt;，而在生产环境中使用&lt;code&gt;settings.production.py&lt;/code&gt;。
docs是文档目录
project目录是项目的apps目录，我们将这个web的apps都放在这个目录下面，比如这里已经有一个users的app，同时我们也看到有static和templates这2个目录，这2个并不是app，而是其他apps需要使用的静态文件目录和模板目录。
requirements目录是放置依赖包的索引文件，我们知道Python使用pip安装Python软件包，所以需要些些Python软件包我们就在一个txt文件里列出这些软件包的名字和版本号。注意我们同样是根据不同的环境有不同的软件包索引，开发环境和生产环境所依赖的Python软件包是不一样的，所以我们也分开在不同的文件中索引。
utility目录放的是一些项目的工具shell，比如运行这个项目操作系统需要安装的一些底层库和软件包等，这些一般是在部署时使用。
怎么创建这个目录结构？
每次开始一个新的Django项目，我们就需要初始化这个项目，创建这个项目的目录结构，然后进行开发。我们知道使用django-admin命令行工具是可以做到这一点的，我们用它来创建了Helloworld项目。而上面这个项目目录结构是怎么创建的呢？接下来我将介绍另一个非常实用的工具&lt;code&gt;cookiecutter&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>cookiecutter for django</title>
      <link>http://danigong.github.io/post/cookiecutter-for-django/</link>
      <pubDate>Mon, 05 Mar 2018 10:59:16 +0800</pubDate>
      
      <guid>http://danigong.github.io/post/cookiecutter-for-django/</guid>
      <description>&lt;p&gt;cookiecutter
这是一个专门用于创建项目目录结构的工具，同时也是使用Python来实现的，它可以使用一个模板来创建一个项目，比如上面我介绍的项目目录结构实际上是一个模板，也是github开源的，链接：&lt;a href=&#34;https://github.com/pydanny/cookiecutter-django&#34;&gt;https://github.com/pydanny/cookiecutter-django&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装cookiecutter
    &lt;code&gt;pip install cookiecutter&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;创建项目
    &lt;code&gt;cookiecutter https://github.com/pydanny/cookiecutter-django&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;运行上面第二个命令的时候，会问你一大堆问题，这些问题中下示例（附简短讲解）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Cloning into &#39;cookiecutter-django&#39;...
remote: Counting objects: 550, done.
remote: Compressing objects: 100% (310/310), done.
remote: Total 550 (delta 283), reused 479 (delta 222)
Receiving objects: 100% (550/550), 127.66 KiB | 58 KiB/s, done.
Resolving deltas: 100% (283/283), done.
# 问你项目叫什么名字，这里可以大小写，带空格
project_name [Project Name]: Reddit Clone
# 问你项目的根目录名字，一般是小写没有空格，这个会生成一个目录
project_slug [reddit_clone]: reddit
# 开发者名字
author_name [Daniel Roy Greenfeld]: Jeffrey Hu
# 开发者邮件
email [you@example.com]: zhiwehu@gmail.com
# 项目简短介绍
description [A short description of the project.]: A reddit clone.
# 项目域名
domain_name [example.com]: lettoo.com
# 项目版本号
version [0.1.0]: 0.0.1
# 时区，就选默认的UTC
timezone [UTC]: 
# 是否使用whitenoise，whitenoise是一个Python实现的静态文件host解决方案，建议初学者选No
use_whitenoise [y]: n
# 是否使用celery，[celery](http://www.celeryproject.org/)是一个Python实现的分布式任务队列解决方案，一般用于后台job，建议初学者选No
use_celery [n]: 
# 是否使用mailhog，mailhog是一个用于本地开发环境测试email的，建议初始选No
use_mailhog [n]: n
# 是否使用sentry，sentry是一个云端日志跟踪和分析平台，Python实现，同时也是开源平台，你可以自己搭建自己的sentry云日志跟踪分析平台。建议初始选No
use_sentry_for_error_reporting [y]: n
# 是否使用opbeat，opbeat是一个云端性能跟踪和分析工具，有一部分错误分析功能，建议初始选No
use_opbeat [n]: n
# 是否使用pycharm，pycharm是一个IDE，由大名鼎鼎的jetbrains公司出品，其出品其他有名的IDE如Idea，Webstorm等，因为我是pycharm开发所以选Yes，如果你不使用这个IDE则选No
use_pycharm [n]: y
# 是否是windows操作系统
windows [n]: n
# 是否使用Python3
use_python3 [y]: y
# 是否使用docker，docker是一个app容器平台，建议初始选No
use_docker [y]: n
# 是否使用heroku，heroku是一个PAAS云平台，用于部署web app，建议初始选No
use_heroku [n]: n
# 是否使用compressor，compressor是一个压缩解决方案，建议初始选No
use_compressor [n]: n
# 使用postgresql版本，这个项目建议本地开发环境和生产环境都使用Postgresql数据库，Postgresql是一个开源数据库，也是Django官方推荐使用的数据库，默认选择1为当前最新的版本。
Select postgresql_version:
1 - 9.5
2 - 9.4
3 - 9.3
4 - 9.2
Choose from 1, 2, 3, 4 [1]: 1
# 选择哪一种JavaScript任务管理器，这里建议初始选None，我们不希望在这里过多的涉及前端的内容。
Select js_task_runner:
1 - Gulp
2 - Grunt
3 - Webpack
4 - None
Choose from 1, 2, 3, 4 [1]: 4
# 是否使用let&#39;s encrypt，let&#39;s encrypt是一个免费生成SSL HTTPS证书的服务，让你的网站免费支持https安全协议，默认选No
use_lets_encrypt [n]: n
# 开源license，默认选1，如果你是私有项目，选5
Select open_source_license:
1 - MIT
2 - BSD
3 - GPLv3
4 - Apache Software License 2.0
5 - Not open source
Choose from 1, 2, 3, 4, 5 [1]: 1
是否使用AWS Elastic Beanstalk，默认选No
use_elasticbeanstalk_experimental: n
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Centos&#43;nginx&#43;uwsgi&#43;django</title>
      <link>http://danigong.github.io/post/django_uwsgi_nginx/</link>
      <pubDate>Sun, 24 Dec 2017 20:50:30 +0800</pubDate>
      
      <guid>http://danigong.github.io/post/django_uwsgi_nginx/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://uwsgi-docs.readthedocs.io/en/latest/tutorials/Django_and_nginx.html&#34;&gt;https://uwsgi-docs.readthedocs.io/en/latest/tutorials/Django_and_nginx.html&lt;/a&gt;
&lt;a href=&#34;http://www.jianshu.com/p/7494560da3e6&#34;&gt;http://www.jianshu.com/p/7494560da3e6&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is our stack:&lt;/p&gt;

&lt;p&gt;the web client &amp;lt;-&amp;gt; the web server &amp;lt;-&amp;gt; the socket &amp;lt;-&amp;gt; uWSGI &amp;lt;-&amp;gt; Python&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Python Coroutine</title>
      <link>http://danigong.github.io/post/python_coroutine/</link>
      <pubDate>Mon, 15 Aug 2016 22:14:50 +0800</pubDate>
      
      <guid>http://danigong.github.io/post/python_coroutine/</guid>
      <description>&lt;p&gt;协程&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;协程，又称微线程，纤程。英文名Coroutine。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;协程的概念很早就提出来了，但直到最近几年才在某些语言（如Lua）中得到广泛应用。&lt;/p&gt;

&lt;p&gt;子程序，或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。&lt;/p&gt;

&lt;p&gt;所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。&lt;/p&gt;

&lt;p&gt;子程序调用总是一个入口，一次返回，调用顺序是明确的。而协程的调用和子程序不同。&lt;/p&gt;

&lt;p&gt;协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。&lt;/p&gt;

&lt;p&gt;注意，在一个子程序中中断，去执行其他子程序，不是函数调用，有点类似CPU的中断。比如子程序A、B：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def A():
    print &#39;1&#39;
    print &#39;2&#39;
    print &#39;3&#39;

def B():
    print &#39;x&#39;
    print &#39;y&#39;
    print &#39;z&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假设由协程执行，在执行A的过程中，可以随时中断，去执行B，B也可能在执行过程中中断再去执行A，结果可能是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1
2
x
y
3
z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是在A中是没有调用B的，所以协程的调用比函数调用理解起来要难一些。&lt;/p&gt;

&lt;p&gt;看起来A、B的执行有点像多线程，但协程的特点在于是一个线程执行，那和多线程比，协程有何优势？&lt;/p&gt;

&lt;p&gt;最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。&lt;/p&gt;

&lt;p&gt;第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。&lt;/p&gt;

&lt;p&gt;因为协程是一个线程执行，那怎么利用多核CPU呢？最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。&lt;/p&gt;

&lt;p&gt;Python对协程的支持还非常有限，用在generator中的yield可以一定程度上实现协程。虽然支持不完全，但已经可以发挥相当大的威力了。&lt;/p&gt;

&lt;p&gt;来看例子：&lt;/p&gt;

&lt;p&gt;传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。&lt;/p&gt;

&lt;p&gt;如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import time

def consumer():
    r = &#39;&#39;
    while True:
        n = yield r
        if not n:
            return
        print(&#39;[CONSUMER] Consuming %s...&#39; % n)
        time.sleep(1)
        r = &#39;200 OK&#39;

def produce(c):
    c.next()
    n = 0
    while n &amp;lt; 5:
        n = n + 1
        print(&#39;[PRODUCER] Producing %s...&#39; % n)
        r = c.send(n)
        print(&#39;[PRODUCER] Consumer return: %s&#39; % r)
    c.close()

if __name__==&#39;__main__&#39;:
    c = consumer()
    produce(c)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[PRODUCER] Producing 1...
[CONSUMER] Consuming 1...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 2...
[CONSUMER] Consuming 2...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 3...
[CONSUMER] Consuming 3...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 4...
[CONSUMER] Consuming 4...
[PRODUCER] Consumer return: 200 OK
[PRODUCER] Producing 5...
[CONSUMER] Consuming 5...
[PRODUCER] Consumer return: 200 OK
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意到consumer函数是一个generator（生成器），把一个consumer传入produce后：&lt;/p&gt;

&lt;p&gt;首先调用c.next()启动生成器；&lt;/p&gt;

&lt;p&gt;然后，一旦生产了东西，通过c.send(n)切换到consumer执行；&lt;/p&gt;

&lt;p&gt;consumer通过yield拿到消息，处理，又通过yield把结果传回；&lt;/p&gt;

&lt;p&gt;produce拿到consumer处理的结果，继续生产下一条消息；&lt;/p&gt;

&lt;p&gt;produce决定不生产了，通过c.close()关闭consumer，整个过程结束。&lt;/p&gt;

&lt;p&gt;整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。&lt;/p&gt;

&lt;p&gt;最后套用Donald Knuth的一句话总结协程的特点：&lt;/p&gt;

&lt;p&gt;“子程序就是协程的一种特例。”&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
	<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.15" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>

  <title> Fluent Python Reading Notes &middot; Pythonic🐶 </title>

  
  <link rel="stylesheet" href="http://danigong.github.io/css/poole.css">
  <link rel="stylesheet" href="http://danigong.github.io/css/syntax.css">
  <link rel="stylesheet" href="http://danigong.github.io/css/hyde.css">
  <link rel="stylesheet" href="http://danigong.github.io/css/style.css"> 
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="" rel="alternate" type="application/rss+xml" title="Pythonic🐶" />
</head>

	<body class="theme-base-0d">
		<div class="sidebar">

  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="http://danigong.github.io/"><h1 style="font-size:35px">Pythonic🐶</h1></a>
      <p class="lead">
       Life is short, I need python 
      </p>
    </div>

    <ul class="sidebar-nav">
      <img src="http://danigong.github.io/img/author.png"></img>
      <li><a href="/">Home</a> </li>
      
        <li><a href="/about/"> About </a></li>
      
        <li><a href="/post/fluent_python_reading_notes/"> FP Note </a></li>
      
    </ul>
    <div class="social-font clearfix">
      GS's&nbsp;
    
    <a href="http://weibo.com/iamastupidboy" target="_blank" title="weibo">Weibo</a>
    
    
    
    <a href="https://github.com/DaniGong" target="_blank" title="github">Github</a>
    
    
    
  </div>
 <p>&copy; 2018. All rights reserved. </p>
  
</div>
  
</div>


		<div class="content container">
			<div class="post" style="word-wrap: break-word;">
			 	<h1>Fluent Python Reading Notes</h1>
			  <span class="post-date">Mon, Mar 12, 2018</span>
			      

<h3 id="1:4a22f77d54a24d61e2db0db0ae70e44d">1</h3>

<blockquote>
<ul>
<li><code>dict()</code> is slower than <code>{}</code></li>
<li><code>list()</code> is slower than <code>()</code></li>
</ul>
</blockquote>

<ul>
<li>[x] 需要符号查找（不能预先知道<code>list()</code>有没有被重定义）</li>
<li>[x] 方法调用</li>
<li>[x] 要检查有没有可迭代变量传入</li>
</ul>

<h3 id="2:4a22f77d54a24d61e2db0db0ae70e44d">2</h3>

<p><strong>特殊方法</strong></p>

<blockquote>
<ul>
<li><code>__len__()</code></li>
<li><code>__getitem__()</code></li>
<li><code>__setitem__()</code></li>
<li><code>__iter__()</code></li>
</ul>
</blockquote>

<p>是为了被<code>python解释器</code>调用的，自己不用调用它们，所以没有<code>A.__len__()</code>方法，只有<code>len(A)</code></p>

<h3 id="3:4a22f77d54a24d61e2db0db0ae70e44d">3</h3>

<p>自定义布尔值 -&gt; 实现<code>__bool__</code></p>

<h3 id="4:4a22f77d54a24d61e2db0db0ae70e44d">4</h3>

<blockquote>
<ul>
<li><code>__str__()</code> : readable, 面向用户</li>
<li><code>__repr__()</code> : unambigous, 面向DEV</li>
</ul>
</blockquote>

<h3 id="5:4a22f77d54a24d61e2db0db0ae70e44d">5</h3>

<p><em>The Zen of Python</em></p>

<ul>
<li>1. 实用胜于纯粹</li>
<li>2. 不能让特例特殊到开始破坏规则</li>
</ul>

<h3 id="6:4a22f77d54a24d61e2db0db0ae70e44d">6</h3>

<p><strong>内置序列类型</strong></p>

<blockquote>
<ul>
<li>容器序列：任意类型，引用 - <code>list, tuple, deque</code></li>

<li><p>扁平序列：单一类型，值 － <code>str(3.0), byte(3.0), bytearray, memoryview</code></p></li>

<li><p>可变序列(MutableSequence)：<code>list, deque</code> &hellip;</p></li>

<li><p>不可变序列(Sequence)：<code>tuple, str, byte</code></p></li>
</ul>
</blockquote>

<h3 id="7:4a22f77d54a24d61e2db0db0ae70e44d">7</h3>

<blockquote>
<ul>
<li>list comprehension = listcomps 列表推导</li>
<li>generator expression = genexps 生成器表达式</li>
</ul>
</blockquote>

<h3 id="8:4a22f77d54a24d61e2db0db0ae70e44d">8</h3>

<blockquote>
<ul>
<li><code>chr(65)</code> -&gt; A</li>
<li><code>ord(A)</code> -&gt; 65</li>
<li><code>unichr(12345)</code> -&gt; u&rsquo;\u3039&rsquo;</li>
</ul>
</blockquote>

<h3 id="9:4a22f77d54a24d61e2db0db0ae70e44d">9</h3>

<p><strong>列表推导的作用只有一个：</strong> 生成列表</p>

<h3 id="10:4a22f77d54a24d61e2db0db0ae70e44d">10</h3>

<p><strong><code>genexps</code>优于<code>listcomps</code></strong></p>

<p><code>genexps</code>遵守了迭代器协议，可以逐个产生元素，而不是先建立一个完整的列表，避免了额外的内存占用</p>

<h3 id="11:4a22f77d54a24d61e2db0db0ae70e44d">11</h3>

<p><strong>元组拆包</strong></p>

<blockquote>
<ul>
<li><code>a,b = (a,b)</code></li>
<li><code>a,b = b,a</code> 两个变量值交换</li>
</ul>
</blockquote>

<h3 id="12:4a22f77d54a24d61e2db0db0ae70e44d">12</h3>

<p><strong><code>*</code>来处理剩下的元素</strong></p>

<p>Python3: <strong>平行赋值</strong>: <code>a,b,*rest = range(5)</code> -&gt; <code>(0,1,[2,3,4])</code></p>

<h3 id="13:4a22f77d54a24d61e2db0db0ae70e44d">13</h3>

<p><code>namedtuple</code>和<code>tuple</code>创建实例消耗内存一样，因为字段名都存在类里：</p>

<blockquote>
<ul>
<li><code>_fileds</code>类属性</li>
<li><code>_make(iterable)</code>类方法</li>
<li><code>_asdict()</code>实例方法</li>
</ul>
</blockquote>

<h3 id="14:4a22f77d54a24d61e2db0db0ae70e44d">14</h3>

<p><code>tuple</code>没有<code>__reversed__</code>方法，但可以<code>reversed(my_tuple)</code></p>

<h3 id="15:4a22f77d54a24d61e2db0db0ae70e44d">15</h3>

<p><strong>切片赋值</strong>：改变<code>list</code>中连续多个值</p>

<pre><code>    l = list(range(10))
    l[2:5] = [20,30]
</code></pre>

<p>-&gt; <code>l:[0,1,20,30,5,6,7,8,9]</code></p>

<h3 id="16:4a22f77d54a24d61e2db0db0ae70e44d">16</h3>

<p><code>__iadd__</code>方法：就地加法</p>

<blockquote>
<ul>
<li><code>+</code> = <code>__iadd__</code></li>
<li><code>*</code> = <code>__imul__</code></li>
</ul>
</blockquote>

<h3 id="17:4a22f77d54a24d61e2db0db0ae70e44d">17</h3>

<p><strong><code>id(object)</code> -&gt; return &ldquo;Identity(内存地址)&rdquo; of an object</strong></p>

<blockquote>
<ul>
<li><code>+=</code> or <code>*=</code> 用在<code>list</code>上，不改变id</li>
<li><code>+=</code> or <code>*=</code> 用在<code>tuple</code>上，改变id，重新创建一个obj</li>
</ul>
</blockquote>

<h3 id="18:4a22f77d54a24d61e2db0db0ae70e44d">18</h3>

<p><strong>如果一个方法对对象进行的是就地改动，那就应该返回<code>None</code></strong></p>

<h3 id="19:4a22f77d54a24d61e2db0db0ae70e44d">19</h3>

<ul>
<li><code>list.sort</code> -&gt; 就地改</li>
<li><code>sorted()</code> -&gt; 新建一个列表返回</li>
</ul>

<p>Example:
<code>sorted(fruits, key=len)</code>
<code>sorted(fruits, key=lower)</code> &hellip;</p>

<h3 id="20:4a22f77d54a24d61e2db0db0ae70e44d">20</h3>

<p><strong><code>bisect</code> 二分查找</strong></p>

<blockquote>
<ul>
<li>1. <code>bisect(haystack, needle)</code></li>
<li>2. <code>insort(seq, item)</code> -&gt; 插入后仍保持升序</li>
</ul>
</blockquote>

<h3 id="21:4a22f77d54a24d61e2db0db0ae70e44d">21</h3>

<p><strong>字符串格式化</strong></p>

<p><code>' '.format(a,b,c)</code></p>

<blockquote>
<ul>
<li><code>{0}</code> -&gt; 位置参数</li>
<li><code>{name}</code> -&gt; 关键字参数</li>
<li><code>{0[0]}</code> -&gt; 对<code>list</code>使用索引</li>
<li><code>{0:*(填充字符)&gt;(右对齐)10(宽度)}</code> -&gt; 填充与格式化</li>
</ul>
</blockquote>

<h3 id="22:4a22f77d54a24d61e2db0db0ae70e44d">22</h3>

<p><code>array</code> 场景-&gt;1000万个浮点数
<code>deque</code> 场景-&gt;需要频繁对序列进行<code>FIFO</code></p>

<h3 id="23:4a22f77d54a24d61e2db0db0ae70e44d">23</h3>

<p><strong><code>memoryview</code></strong></p>

<h3 id="24:4a22f77d54a24d61e2db0db0ae70e44d">24</h3>

<p><strong><code>numpy, scipy</code></strong></p>

<h3 id="25:4a22f77d54a24d61e2db0db0ae70e44d">25</h3>

<p><strong><code>collections.deque</code></strong>：线程安全、快速从两端添加、删除元素。</p>

<p>*场景*：存放最近使用的几个元素</p>

<blockquote>
<ul>
<li>1. <code>rotate(3)</code>：右边三个到左边。<code>rotate(-4)</code>：左边四个到右边。</li>
<li>2. <code>appendleft()</code>：单个。<code>extend, extendleft</code>： 队列。</li>
</ul>
</blockquote>

<h3 id="26:4a22f77d54a24d61e2db0db0ae70e44d">26</h3>

<ul>
<li><strong><code>散列表</code></strong>是<code>字典</code>类型性能出众的根本原因。</li>
<li><strong><code>collections.abc.Mapping</code>的instance</strong></li>
<li><strong>原子不可变数据类型</strong>（<code>str, byte</code>和数值类型）</li>
<li><strong>散列值</strong>就是<code>id()</code>函数的返回值</li>
</ul>

<h3 id="27:4a22f77d54a24d61e2db0db0ae70e44d">27</h3>

<p><strong>字典创建方法</strong></p>

<blockquote>
<ul>
<li>1. <code>a = dict(one=1,two=2,three=3)</code></li>
<li>2. <code>b = {'one':1,'two':2,'three':3}</code></li>
<li>3. <code>c = dict(zip(['one','two','three'],[1,2,3]))</code></li>
<li>4. 字典推导 <code>dictcomp</code></li>
</ul>
</blockquote>

<h3 id="28:4a22f77d54a24d61e2db0db0ae70e44d">28</h3>

<p><strong><code>dict.setdefault</code></strong>处理不存在于<code>dict</code>中的<code>key</code></p>

<h3 id="29:4a22f77d54a24d61e2db0db0ae70e44d">29</h3>

<p><strong><code>collections.defaultdict</code></strong>是处理找不到<code>key</code>的一个选择</p>

<p><code>dd = defautdict(list)</code>，如果<code>'new-key'</code>不存在，<code>dd['new-key']</code>会执行：</p>

<blockquote>
<ul>
<li>1. <code>list()</code>建新列表</li>
<li>2. 这个新列表作为<code>值</code>，<code>new-key</code>为<code>key</code>，放入<code>dd</code></li>
<li>3. 返回这个列表的引用</li>
</ul>
</blockquote>

<h3 id="30:4a22f77d54a24d61e2db0db0ae70e44d">30</h3>

<p><strong><code>__missing__</code>只会被<code>__getitem__</code>调用</strong></p>

<h3 id="31:4a22f77d54a24d61e2db0db0ae70e44d">31</h3>

<p><strong>如果要自定义一个映射类型，应该继承<code>collections.UserDict</code></strong></p>

<h3 id="32:4a22f77d54a24d61e2db0db0ae70e44d">32</h3>

<p><strong>字典的变种</strong></p>

<blockquote>
<ul>
<li>1. <code>collections.OrderedDict</code>: <code>popitem</code>方法 -&gt; 删除并返回</li>
<li>2. <code>collections.ChainMap</code>: 多个字典逐个查找</li>
<li>3. <code>collections.Counter</code>:</li>
</ul>

<blockquote>
<pre><code>    ct = Counter('abracadabra')
</code></pre>

<ul>
<li>-&gt;</li>
</ul>

<pre><code>    Counter({'a':5,'b':2,'r':2,'c':1,'d':1})
</code></pre>
</blockquote>

<ul>
<li>4. <code>UserDict</code>用户涌来继承写子类</li>
<li>5. <code>TransformDict</code></li>
</ul>
</blockquote>

<h3 id="33:4a22f77d54a24d61e2db0db0ae70e44d">33</h3>

<p><strong>不可变映射类型</strong></p>

<ul>
<li><code>types.MappingProxyType</code>：<code>只读的映射视图</code></li>
</ul>

<h3 id="34:4a22f77d54a24d61e2db0db0ae70e44d">34</h3>

<p><code>set</code> -&gt; 许多唯一对象的聚集；<code>frozenset</code> -&gt; 不可变</p>

<p><strong>集合</strong></p>

<blockquote>
<ul>
<li>1. 用于去重复：<code>list</code> -&gt; <code>set</code> -&gt; <code>list</code></li>
<li>2. 合集，交集，差集 -&gt; 场景：元素出现次数</li>
</ul>
</blockquote>

<p><strong>如果是空集必须写成<code>set()</code></strong></p>

<h3 id="35:4a22f77d54a24d61e2db0db0ae70e44d">35</h3>

<p><strong>散列表</strong>：稀疏数组（总有空白元素的数组）
<code>key:value</code> -&gt; 一个<code>表元</code></p>

<p>因为所有表元大小一致，所以可以通过<code>偏移量</code>来读取某个表元</p>

<p>用<code>hash()</code>来计算<code>散列值</code></p>

<h3 id="36:4a22f77d54a24d61e2db0db0ae70e44d">36</h3>

<p>存放数量巨大的记录用<code>tuple</code>或<code>namedtuple</code></p>

<p><code>dict</code> 散列 -&gt; 内存消耗大</p>

<h3 id="37:4a22f77d54a24d61e2db0db0ae70e44d">37</h3>

<p><strong><code>dict</code></strong>：<strong>空间</strong>换<strong>时间</strong> -&gt; <strong>读取快</strong> 但 <strong>内存消耗大</strong></p>

<p>Python解释器可能为字典扩容 -&gt; 导致新建一个更大的散列表</p>

<h3 id="38:4a22f77d54a24d61e2db0db0ae70e44d">38</h3>

<p><strong>集合 <code>set</code></strong></p>

<blockquote>
<ul>
<li>1. 元素必须可散列</li>
<li>2. 很耗内存</li>
<li>3. 高效查找</li>
<li>4. 次序取决于添加次序</li>
<li>5. 添加元素可能改变已有元素次序(*37*中的扩容)</li>
</ul>
</blockquote>

<h3 id="39:4a22f77d54a24d61e2db0db0ae70e44d">39</h3>

<p><strong>字符</strong>的最佳定义是<code>Unicode</code>字符</p>

<p><code>Python3</code> 从 <code>str</code>对象中获取的元素是<code>Unicode</code>字符</p>

<p><strong><em>字符的具体表述取决于所用的编码</em></strong></p>

<blockquote>
<ul>
<li>编码：码位 -&gt; 字节序列</li>
<li>解码：字节序列 -&gt; 码位（字符的标识）</li>
</ul>
</blockquote>

<h3 id="40:4a22f77d54a24d61e2db0db0ae70e44d">40</h3>

<p><strong>字面量</strong>：双眼所见</p>

<h3 id="41:4a22f77d54a24d61e2db0db0ae70e44d">41</h3>

<p><code>utf_8</code> 的别名：<code>utf8</code>, <code>u8</code>, <code>utf-8</code></p>

<h3 id="42:4a22f77d54a24d61e2db0db0ae70e44d">42</h3>

<p><strong>编码种类</strong></p>

<blockquote>
<ul>
<li><code>latin1</code>(iso8859-1)：是其他编码的基础</li>
<li><code>cp1252</code>：Windows制定的<code>latin1</code>的超集，添加了有用的符号</li>
<li><code>gb2312</code>：用于编码简体中文的<strong>陈旧</strong>标准</li>
<li><code>utf-8</code>：web最常见的8位编码，与<code>ASCII</code>兼容</li>
</ul>
</blockquote>

<h3 id="43:4a22f77d54a24d61e2db0db0ae70e44d">43</h3>

<p>Python3 中默认使用 <code>utf8</code> 编码源码</p>

<h3 id="44:4a22f77d54a24d61e2db0db0ae70e44d">44</h3>

<p><strong>判断编码</strong></p>

<p>以下是肉眼方法</p>

<blockquote>
<ul>
<li>1. <code>HTTP</code>和<code>XML</code>，包含明确指明内容编码的<em>首部</em></li>
<li>2. 包含大于127的字节值，那么就不是ASCII</li>
<li>3. 如果 <code>b'\x00'</code> 经常出现，那么就不是8位编码方案</li>
</ul>
</blockquote>

<p>统一字符编码侦测包：<code>Chardet</code></p>

<h3 id="45:4a22f77d54a24d61e2db0db0ae70e44d">45</h3>

<p><strong>Python中，函数是一等对象</strong></p>

<blockquote>
<ul>
<li>1. 运行时创建</li>
<li>2. 能赋值给变量或数据结构中的元素</li>
<li>3. 能作为参数传给函数</li>
<li>4. 能被<code>return</code></li>
</ul>
</blockquote>

<h3 id="46:4a22f77d54a24d61e2db0db0ae70e44d">46</h3>

<p><strong><code>__doc__</code>用于生成对象的帮助文本</strong></p>

<h3 id="47:4a22f77d54a24d61e2db0db0ae70e44d">47</h3>

<p><strong>函数式编程</strong>：特点之一是使用高阶函数</p>

<p>高阶函数：</p>

<blockquote>
<ul>
<li>1. 接受函数作为参数</li>
<li><em>或</em></li>
<li>2. 把函数作为结果返回</li>
</ul>
</blockquote>

<h3 id="48:4a22f77d54a24d61e2db0db0ae70e44d">48</h3>

<p><code>map, filter 和 reduce</code> 在Python3中已经不是内置函数
被 <code>listcomps</code> 和 <code>genexps</code> 所替代（可读性原因）</p>

<h3 id="49:4a22f77d54a24d61e2db0db0ae70e44d">49</h3>

<p>匿名函数：<code>lambda</code></p>

<h3 id="50:4a22f77d54a24d61e2db0db0ae70e44d">50</h3>

<p>使用<code>callable()</code>函数来判断一个对象能否调用</p>

<h3 id="51:4a22f77d54a24d61e2db0db0ae70e44d">51</h3>

<p>用户定义可调用类型，只需实现实例方法<code>__call__</code></p>

<h3 id="52:4a22f77d54a24d61e2db0db0ae70e44d">52</h3>

<p><strong>函数内省</strong></p>

<h3 id="53:4a22f77d54a24d61e2db0db0ae70e44d">53</h3>

<p><strong>函数有但一般对象没有的特殊方法：</strong></p>

<blockquote>
<ul>
<li><code>__annotations__</code></li>
<li><code>__call__</code>：实现<code>()</code>运算符</li>
</ul>
</blockquote>

<h3 id="54:4a22f77d54a24d61e2db0db0ae70e44d">54</h3>

<p><strong>函数注解</strong>只存放在<code>__annotations__</code>属性里，Python不做检查、验证、强制&hellip;</p>

<p>注解只是元数据，可以供IDE、框架和装饰器工具使用</p>

<h3 id="55:4a22f77d54a24d61e2db0db0ae70e44d">55</h3>

<p><strong>函数式编程</strong></p>

<blockquote>
<ul>
<li>1. <code>operator</code> -&gt; <code>itemgetter</code>(get下标)，<code>attrgetter</code>(get name)</li>
<li>2. <code>functools</code> 内包含 <code>reduce</code>函数，<code>partial</code>冻结参数，<code>partialmethod</code></li>
</ul>
</blockquote>

<p>Example:</p>

<blockquote>
<pre><code>    triple = partial(mul,3)
    triple(7) -&gt; 21
</code></pre>
</blockquote>

<h3 id="56:4a22f77d54a24d61e2db0db0ae70e44d">56</h3>

<p><code>globals()</code> <strong>策略模式</strong></p>

<h3 id="57:4a22f77d54a24d61e2db0db0ae70e44d">57</h3>

<p><strong>命令模式</strong>：是回调机制的面向对象替代品</p>

<h3 id="58:4a22f77d54a24d61e2db0db0ae70e44d">58</h3>

<p><code>nonlocal</code>关键字。</p>

<p><strong>装饰器</strong> 目的是增强函数</p>

<h3 id="59:4a22f77d54a24d61e2db0db0ae70e44d">59</h3>

<p><strong>元编程</strong> -&gt; 在运行时改变程序的行为</p>

<p><strong>装饰器的两大特性</strong>：</p>

<blockquote>
<ul>
<li>1. 能把装饰的函数替换成其他函数</li>
<li>2. 在加载模块时立即执行</li>
</ul>
</blockquote>

<h3 id="60:4a22f77d54a24d61e2db0db0ae70e44d">60</h3>

<p><strong>装饰器</strong> 在被装饰的函数定义之后立即运行。通常是在导入时（加载模块时）</p>

<h3 id="61:4a22f77d54a24d61e2db0db0ae70e44d">61</h3>

<p><strong>变量作用域规则</strong></p>

<pre><code>    b = 6
    def f2(a):
        print(a)
        print(b)
        b = 9
    
    f2(3)
</code></pre>

<p>输出 <code>3</code>, <code>local variable 'b' referenced before assignment</code></p>

<p>Python编译函数定义体时，它判断<code>b</code>是局部变量，因为在函数中给它赋值了。生成的字节码证实了这种判断，Python会尝试从本地环境获取<code>b</code>。后面调用<code>f2(3)</code>时，<code>f2</code>的定义体会获取并打印局部变量<code>a</code>的值，但是尝试获取局部变量<code>b</code>的值时，发现<code>b</code>没有绑定值。</p>

<p><strong>这不是缺陷</strong>，而是<strong>设计选择</strong>：Python不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量。</p>

<p>如果在函数中赋值时想让解释器把<code>b</code>当成全局变量，要使用<code>global</code>声明。</p>

<h3 id="62:4a22f77d54a24d61e2db0db0ae70e44d">62</h3>

<p><strong>闭包</strong> 不等同于 <strong>匿名函数</strong></p>

<p><strong>闭包是延伸了作用域的函数</strong>，函数是不是匿名的没有关系，关键是它能否访问定义体<strong>之外</strong>定义的<strong>非</strong>全局变量</p>

			</div>

			
		</div>
		
  </body>
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-115398530-1', 'auto');
  ga('send', 'pageview');
  $('#messagesbsb').remove();
</script>



  </html>


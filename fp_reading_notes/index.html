<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8">
<meta name="description" content="Fluent Python Reading Notes">
<meta name="generator" content="Hugo 0.84.1" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="/css/style.css" type="text/css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400,700" type="text/css">
<link rel="alternate" href="/index.xml" type="application/rss+xml" title="G eek S">
<title>Fluent Python Reading Notes - G eek S</title>
</head>
<body>

<header>
  <div class="container clearfix">
    <a class="path" href="http://danigong.github.io/">[G eek S]</a>
    <span class="caret"># _</span>
    <div class="right">
      
    </div>
  </div>
</header>

<div class="container">


<main role="main" class="article">
  
<article class="single" itemscope itemtype="http://schema.org/BlogPosting">
  <div class="meta">

    <span class="key">published on</span>
    <span class="val"><time itemprop="datePublished" datetime="2018-03-12">March 12, 2018</time></span>



    <br>
    <span class="key">tags:</span>
    <span class="val">

        <a href="/tags/python">python</a>

    </span>

  </div>
  <h1 class="headline" itemprop="headline">Fluent Python Reading Notes</h1>
  <section class="body" itemprop="articleBody">
    <h3 id="1">1</h3>
<blockquote>
<ul>
<li><code>dict()</code> is slower than <code>{}</code></li>
<li><code>list()</code> is slower than <code>()</code></li>
</ul>
</blockquote>
<ul>
<li><input checked="" disabled="" type="checkbox"> 需要符号查找（不能预先知道<code>list()</code>有没有被重定义）</li>
<li><input checked="" disabled="" type="checkbox"> 方法调用</li>
<li><input checked="" disabled="" type="checkbox"> 要检查有没有可迭代变量传入</li>
</ul>
<h3 id="2">2</h3>
<p><strong>特殊方法</strong></p>
<blockquote>
<ul>
<li><code>__len__()</code></li>
<li><code>__getitem__()</code></li>
<li><code>__setitem__()</code></li>
<li><code>__iter__()</code></li>
</ul>
</blockquote>
<p>是为了被<code>python解释器</code>调用的，自己不用调用它们，所以没有<code>A.__len__()</code>方法，只有<code>len(A)</code></p>
<h3 id="3">3</h3>
<p>自定义布尔值 -&gt; 实现<code>__bool__</code></p>
<h3 id="4">4</h3>
<blockquote>
<ul>
<li><code>__str__()</code> : readable, 面向用户</li>
<li><code>__repr__()</code> : unambigous, 面向DEV</li>
</ul>
</blockquote>
<h3 id="5">5</h3>
<p><em>The Zen of Python</em></p>
<ul>
<li>
<ol>
<li>实用胜于纯粹</li>
</ol>
</li>
<li>
<ol start="2">
<li>不能让特例特殊到开始破坏规则</li>
</ol>
</li>
</ul>
<h3 id="6">6</h3>
<p><strong>内置序列类型</strong></p>
<blockquote>
<ul>
<li>容器序列：任意类型，引用 - <code>list, tuple, deque</code></li>
<li>扁平序列：单一类型，值 － <code>str(3.0), byte(3.0), bytearray, memoryview</code></li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>可变序列(MutableSequence)：<code>list, deque</code> &hellip;</li>
<li>不可变序列(Sequence)：<code>tuple, str, byte</code></li>
</ul>
</blockquote>
<h3 id="7">7</h3>
<blockquote>
<ul>
<li>list comprehension = listcomps 列表推导</li>
<li>generator expression = genexps 生成器表达式</li>
</ul>
</blockquote>
<h3 id="8">8</h3>
<blockquote>
<ul>
<li><code>chr(65)</code> -&gt; A</li>
<li><code>ord(A)</code> -&gt; 65</li>
<li><code>unichr(12345)</code> -&gt; u'\u3039'</li>
</ul>
</blockquote>
<h3 id="9">9</h3>
<p><strong>列表推导的作用只有一个：</strong> 生成列表</p>
<h3 id="10">10</h3>
<p><strong><code>genexps</code>优于<code>listcomps</code></strong></p>
<p><code>genexps</code>遵守了迭代器协议，可以逐个产生元素，而不是先建立一个完整的列表，避免了额外的内存占用</p>
<h3 id="11">11</h3>
<p><strong>元组拆包</strong></p>
<blockquote>
<ul>
<li><code>a,b = (a,b)</code></li>
<li><code>a,b = b,a</code> 两个变量值交换</li>
</ul>
</blockquote>
<h3 id="12">12</h3>
<p><strong><code>*</code>来处理剩下的元素</strong></p>
<p>Python3: <strong>平行赋值</strong>: <code>a,b,*rest = range(5)</code> -&gt; <code>(0,1,[2,3,4])</code></p>
<h3 id="13">13</h3>
<p><code>namedtuple</code>和<code>tuple</code>创建实例消耗内存一样，因为字段名都存在类里：</p>
<blockquote>
<ul>
<li><code>_fileds</code>类属性</li>
<li><code>_make(iterable)</code>类方法</li>
<li><code>_asdict()</code>实例方法</li>
</ul>
</blockquote>
<h3 id="14">14</h3>
<p><code>tuple</code>没有<code>__reversed__</code>方法，但可以<code>reversed(my_tuple)</code></p>
<h3 id="15">15</h3>
<p><strong>切片赋值</strong>：改变<code>list</code>中连续多个值</p>
<pre><code>    l = list(range(10))
    l[2:5] = [20,30]
</code></pre><p>-&gt; <code>l:[0,1,20,30,5,6,7,8,9]</code></p>
<h3 id="16">16</h3>
<p><code>__iadd__</code>方法：就地加法</p>
<blockquote>
<ul>
<li><code>+</code> = <code>__iadd__</code></li>
<li><code>*</code> = <code>__imul__</code></li>
</ul>
</blockquote>
<h3 id="17">17</h3>
<p><strong><code>id(object)</code> -&gt; return &ldquo;Identity(内存地址)&rdquo; of an object</strong></p>
<blockquote>
<ul>
<li><code>+=</code> or <code>*=</code> 用在<code>list</code>上，不改变id</li>
<li><code>+=</code> or <code>*=</code> 用在<code>tuple</code>上，改变id，重新创建一个obj</li>
</ul>
</blockquote>
<h3 id="18">18</h3>
<p><strong>如果一个方法对对象进行的是就地改动，那就应该返回<code>None</code></strong></p>
<h3 id="19">19</h3>
<ul>
<li><code>list.sort</code> -&gt; 就地改</li>
<li><code>sorted()</code> -&gt; 新建一个列表返回</li>
</ul>
<p>Example:
<code>sorted(fruits, key=len)</code>
<code>sorted(fruits, key=lower)</code> &hellip;</p>
<h3 id="20">20</h3>
<p><strong><code>bisect</code> 二分查找</strong></p>
<blockquote>
<ul>
<li>
<ol>
<li><code>bisect(haystack, needle)</code></li>
</ol>
</li>
<li>
<ol start="2">
<li><code>insort(seq, item)</code> -&gt; 插入后仍保持升序</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="21">21</h3>
<p><strong>字符串格式化</strong></p>
<p><code>' '.format(a,b,c)</code></p>
<blockquote>
<ul>
<li><code>{0}</code> -&gt; 位置参数</li>
<li><code>{name}</code> -&gt; 关键字参数</li>
<li><code>{0[0]}</code> -&gt; 对<code>list</code>使用索引</li>
<li><code>{0:*(填充字符)&gt;(右对齐)10(宽度)}</code> -&gt; 填充与格式化</li>
</ul>
</blockquote>
<h3 id="22">22</h3>
<p><code>array</code> 场景-&gt;1000万个浮点数
<code>deque</code> 场景-&gt;需要频繁对序列进行<code>FIFO</code></p>
<h3 id="23">23</h3>
<p><strong><code>memoryview</code></strong></p>
<h3 id="24">24</h3>
<p><strong><code>numpy, scipy</code></strong></p>
<h3 id="25">25</h3>
<p><strong><code>collections.deque</code></strong>：线程安全、快速从两端添加、删除元素。</p>
<p><em>场景</em>：存放最近使用的几个元素</p>
<blockquote>
<ul>
<li>
<ol>
<li><code>rotate(3)</code>：右边三个到左边。<code>rotate(-4)</code>：左边四个到右边。</li>
</ol>
</li>
<li>
<ol start="2">
<li><code>appendleft()</code>：单个。<code>extend, extendleft</code>： 队列。</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="26">26</h3>
<ul>
<li>**<code>散列表</code>**是<code>字典</code>类型性能出众的根本原因。</li>
<li><strong><code>collections.abc.Mapping</code>的instance</strong></li>
<li><strong>原子不可变数据类型</strong>（<code>str, byte</code>和数值类型）</li>
<li><strong>散列值</strong>就是<code>id()</code>函数的返回值</li>
</ul>
<h3 id="27">27</h3>
<p><strong>字典创建方法</strong></p>
<blockquote>
<ul>
<li>
<ol>
<li><code>a = dict(one=1,two=2,three=3)</code></li>
</ol>
</li>
<li>
<ol start="2">
<li><code>b = {'one':1,'two':2,'three':3}</code></li>
</ol>
</li>
<li>
<ol start="3">
<li><code>c = dict(zip(['one','two','three'],[1,2,3]))</code></li>
</ol>
</li>
<li>
<ol start="4">
<li>字典推导 <code>dictcomp</code></li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="28">28</h3>
<p>**<code>dict.setdefault</code>**处理不存在于<code>dict</code>中的<code>key</code></p>
<h3 id="29">29</h3>
<p>**<code>collections.defaultdict</code>**是处理找不到<code>key</code>的一个选择</p>
<p><code>dd = defautdict(list)</code>，如果<code>'new-key'</code>不存在，<code>dd['new-key']</code>会执行：</p>
<blockquote>
<ul>
<li>
<ol>
<li><code>list()</code>建新列表</li>
</ol>
</li>
<li>
<ol start="2">
<li>这个新列表作为<code>值</code>，<code>new-key</code>为<code>key</code>，放入<code>dd</code></li>
</ol>
</li>
<li>
<ol start="3">
<li>返回这个列表的引用</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="30">30</h3>
<p><strong><code>__missing__</code>只会被<code>__getitem__</code>调用</strong></p>
<h3 id="31">31</h3>
<p><strong>如果要自定义一个映射类型，应该继承<code>collections.UserDict</code></strong></p>
<h3 id="32">32</h3>
<p><strong>字典的变种</strong></p>
<blockquote>
<ul>
<li>
<ol>
<li><code>collections.OrderedDict</code>: <code>popitem</code>方法 -&gt; 删除并返回</li>
</ol>
</li>
<li>
<ol start="2">
<li><code>collections.ChainMap</code>: 多个字典逐个查找</li>
</ol>
</li>
<li>
<ol start="3">
<li><code>collections.Counter</code>:</li>
</ol>
</li>
</ul>
</blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
<pre><code>    ct = Counter('abracadabra')
</code></pre><blockquote>
<blockquote>
<ul>
<li>-&gt;</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
<pre><code>    Counter({'a':5,'b':2,'r':2,'c':1,'d':1})
</code></pre><blockquote>
<ul>
<li>
<ol start="4">
<li><code>UserDict</code>用户涌来继承写子类</li>
</ol>
</li>
<li>
<ol start="5">
<li><code>TransformDict</code></li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="33">33</h3>
<p><strong>不可变映射类型</strong></p>
<ul>
<li><code>types.MappingProxyType</code>：<code>只读的映射视图</code></li>
</ul>
<h3 id="34">34</h3>
<p><code>set</code> -&gt; 许多唯一对象的聚集；<code>frozenset</code> -&gt; 不可变</p>
<p><strong>集合</strong></p>
<blockquote>
<ul>
<li>
<ol>
<li>用于去重复：<code>list</code> -&gt; <code>set</code> -&gt; <code>list</code></li>
</ol>
</li>
<li>
<ol start="2">
<li>合集，交集，差集 -&gt; 场景：元素出现次数</li>
</ol>
</li>
</ul>
</blockquote>
<p><strong>如果是空集必须写成<code>set()</code></strong></p>
<h3 id="35">35</h3>
<p><strong>散列表</strong>：稀疏数组（总有空白元素的数组）
<code>key:value</code> -&gt; 一个<code>表元</code></p>
<p>因为所有表元大小一致，所以可以通过<code>偏移量</code>来读取某个表元</p>
<p>用<code>hash()</code>来计算<code>散列值</code></p>
<h3 id="36">36</h3>
<p>存放数量巨大的记录用<code>tuple</code>或<code>namedtuple</code></p>
<p><code>dict</code> 散列 -&gt; 内存消耗大</p>
<h3 id="37">37</h3>
<p><strong><code>dict</code></strong>：<strong>空间</strong>换<strong>时间</strong> -&gt; <strong>读取快</strong> 但 <strong>内存消耗大</strong></p>
<p>Python解释器可能为字典扩容 -&gt; 导致新建一个更大的散列表</p>
<h3 id="38">38</h3>
<p><strong>集合 <code>set</code></strong></p>
<blockquote>
<ul>
<li>
<ol>
<li>元素必须可散列</li>
</ol>
</li>
<li>
<ol start="2">
<li>很耗内存</li>
</ol>
</li>
<li>
<ol start="3">
<li>高效查找</li>
</ol>
</li>
<li>
<ol start="4">
<li>次序取决于添加次序</li>
</ol>
</li>
<li>
<ol start="5">
<li>添加元素可能改变已有元素次序(<em>37</em>中的扩容)</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="39">39</h3>
<p><strong>字符</strong>的最佳定义是<code>Unicode</code>字符</p>
<p><code>Python3</code> 从 <code>str</code>对象中获取的元素是<code>Unicode</code>字符</p>
<p><em><strong>字符的具体表述取决于所用的编码</strong></em></p>
<blockquote>
<ul>
<li>编码：码位 -&gt; 字节序列</li>
<li>解码：字节序列 -&gt; 码位（字符的标识）</li>
</ul>
</blockquote>
<h3 id="40">40</h3>
<p><strong>字面量</strong>：双眼所见</p>
<h3 id="41">41</h3>
<p><code>utf_8</code> 的别名：<code>utf8</code>, <code>u8</code>, <code>utf-8</code></p>
<h3 id="42">42</h3>
<p><strong>编码种类</strong></p>
<blockquote>
<ul>
<li><code>latin1</code>(iso8859-1)：是其他编码的基础</li>
<li><code>cp1252</code>：Windows制定的<code>latin1</code>的超集，添加了有用的符号</li>
<li><code>gb2312</code>：用于编码简体中文的<strong>陈旧</strong>标准</li>
<li><code>utf-8</code>：web最常见的8位编码，与<code>ASCII</code>兼容</li>
</ul>
</blockquote>
<h3 id="43">43</h3>
<p>Python3 中默认使用 <code>utf8</code> 编码源码</p>
<h3 id="44">44</h3>
<p><strong>判断编码</strong></p>
<p>以下是肉眼方法</p>
<blockquote>
<ul>
<li>
<ol>
<li><code>HTTP</code>和<code>XML</code>，包含明确指明内容编码的<em>首部</em></li>
</ol>
</li>
<li>
<ol start="2">
<li>包含大于127的字节值，那么就不是ASCII</li>
</ol>
</li>
<li>
<ol start="3">
<li>如果 <code>b'\x00'</code> 经常出现，那么就不是8位编码方案</li>
</ol>
</li>
</ul>
</blockquote>
<p>统一字符编码侦测包：<code>Chardet</code></p>
<h3 id="45">45</h3>
<p><strong>Python中，函数是一等对象</strong></p>
<blockquote>
<ul>
<li>
<ol>
<li>运行时创建</li>
</ol>
</li>
<li>
<ol start="2">
<li>能赋值给变量或数据结构中的元素</li>
</ol>
</li>
<li>
<ol start="3">
<li>能作为参数传给函数</li>
</ol>
</li>
<li>
<ol start="4">
<li>能被<code>return</code></li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="46">46</h3>
<p><strong><code>__doc__</code>用于生成对象的帮助文本</strong></p>
<h3 id="47">47</h3>
<p><strong>函数式编程</strong>：特点之一是使用高阶函数</p>
<p>高阶函数：</p>
<blockquote>
<ul>
<li>
<ol>
<li>接受函数作为参数</li>
</ol>
</li>
<li><em>或</em></li>
<li>
<ol start="2">
<li>把函数作为结果返回</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="48">48</h3>
<p><code>map, filter 和 reduce</code> 在Python3中已经不是内置函数
被 <code>listcomps</code> 和 <code>genexps</code> 所替代（可读性原因）</p>
<h3 id="49">49</h3>
<p>匿名函数：<code>lambda</code></p>
<h3 id="50">50</h3>
<p>使用<code>callable()</code>函数来判断一个对象能否调用</p>
<h3 id="51">51</h3>
<p>用户定义可调用类型，只需实现实例方法<code>__call__</code></p>
<h3 id="52">52</h3>
<p><strong>函数内省</strong></p>
<h3 id="53">53</h3>
<p><strong>函数有但一般对象没有的特殊方法：</strong></p>
<blockquote>
<ul>
<li><code>__annotations__</code></li>
<li><code>__call__</code>：实现<code>()</code>运算符</li>
</ul>
</blockquote>
<h3 id="54">54</h3>
<p><strong>函数注解</strong>只存放在<code>__annotations__</code>属性里，Python不做检查、验证、强制&hellip;</p>
<p>注解只是元数据，可以供IDE、框架和装饰器工具使用</p>
<h3 id="55">55</h3>
<p><strong>函数式编程</strong></p>
<blockquote>
<ul>
<li>
<ol>
<li><code>operator</code> -&gt; <code>itemgetter</code>(get下标)，<code>attrgetter</code>(get name)</li>
</ol>
</li>
<li>
<ol start="2">
<li><code>functools</code> 内包含 <code>reduce</code>函数，<code>partial</code>冻结参数，<code>partialmethod</code></li>
</ol>
</li>
</ul>
</blockquote>
<p>Example:</p>
<blockquote>
</blockquote>
<pre><code>    triple = partial(mul,3)
    triple(7) -&gt; 21
</code></pre><h3 id="56">56</h3>
<p><code>globals()</code> <strong>策略模式</strong></p>
<h3 id="57">57</h3>
<p><strong>命令模式</strong>：是回调机制的面向对象替代品</p>
<h3 id="58">58</h3>
<p><code>nonlocal</code>关键字。</p>
<p><strong>装饰器</strong> 目的是增强函数</p>
<h3 id="59">59</h3>
<p><strong>元编程</strong> -&gt; 在运行时改变程序的行为</p>
<p><strong>装饰器的两大特性</strong>：</p>
<blockquote>
<ul>
<li>
<ol>
<li>能把装饰的函数替换成其他函数</li>
</ol>
</li>
<li>
<ol start="2">
<li>在加载模块时立即执行</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="60">60</h3>
<p><strong>装饰器</strong> 在被装饰的函数定义之后立即运行。通常是在导入时（加载模块时）</p>
<h3 id="61">61</h3>
<p><strong>变量作用域规则</strong></p>
<pre><code>    b = 6
    def f2(a):
        print(a)
        print(b)
        b = 9
    
    f2(3)
</code></pre><p>输出 <code>3</code>, <code>local variable 'b' referenced before assignment</code></p>
<p>Python编译函数定义体时，它判断<code>b</code>是局部变量，因为在函数中给它赋值了。生成的字节码证实了这种判断，Python会尝试从本地环境获取<code>b</code>。后面调用<code>f2(3)</code>时，<code>f2</code>的定义体会获取并打印局部变量<code>a</code>的值，但是尝试获取局部变量<code>b</code>的值时，发现<code>b</code>没有绑定值。</p>
<p><strong>这不是缺陷</strong>，而是<strong>设计选择</strong>：Python不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量。</p>
<p>如果在函数中赋值时想让解释器把<code>b</code>当成全局变量，要使用<code>global</code>声明。</p>
<h3 id="62">62</h3>
<p><strong>闭包</strong> 不等同于 <strong>匿名函数</strong></p>
<p><strong>闭包是延伸了作用域的函数</strong>，函数是不是匿名的没有关系，关键是它能否访问定义体<strong>之外</strong>定义的<strong>非</strong>全局变量</p>

  </section>
</article>

</main>

</div>

<footer>
  <div class="container">
    <span class="copyright">&copy; 2021 G eek S - <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a></span>
  </div>
</footer>

</body>
</html>

